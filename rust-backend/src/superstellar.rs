// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protobuf/superstellar.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message oneof groups
    pub content: ::std::option::Option<Message_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Message_oneof_content {
    space(Space),
    hello(Hello),
    playerLeft(PlayerLeft),
    projectileFired(ProjectileFired),
    projectileHit(ProjectileHit),
    playerJoined(PlayerJoined),
    joinGameAck(JoinGameAck),
    leaderboard(Leaderboard),
    playerDied(PlayerDied),
    pong(Pong),
    scoreBoard(ScoreBoard),
    constants(Constants),
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .superstellar.Space space = 1;


    pub fn get_space(&self) -> &Space {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::space(ref v)) => v,
            _ => <Space as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_space(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_space(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::space(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: Space) {
        self.content = ::std::option::Option::Some(Message_oneof_content::space(v))
    }

    // Mutable pointer to the field.
    pub fn mut_space(&mut self) -> &mut Space {
        if let ::std::option::Option::Some(Message_oneof_content::space(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::space(Space::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::space(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_space(&mut self) -> Space {
        if self.has_space() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::space(v)) => v,
                _ => panic!(),
            }
        } else {
            Space::new()
        }
    }

    // .superstellar.Hello hello = 2;


    pub fn get_hello(&self) -> &Hello {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::hello(ref v)) => v,
            _ => <Hello as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_hello(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_hello(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::hello(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hello(&mut self, v: Hello) {
        self.content = ::std::option::Option::Some(Message_oneof_content::hello(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hello(&mut self) -> &mut Hello {
        if let ::std::option::Option::Some(Message_oneof_content::hello(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::hello(Hello::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::hello(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hello(&mut self) -> Hello {
        if self.has_hello() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::hello(v)) => v,
                _ => panic!(),
            }
        } else {
            Hello::new()
        }
    }

    // .superstellar.PlayerLeft playerLeft = 3;


    pub fn get_playerLeft(&self) -> &PlayerLeft {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerLeft(ref v)) => v,
            _ => <PlayerLeft as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_playerLeft(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_playerLeft(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerLeft(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_playerLeft(&mut self, v: PlayerLeft) {
        self.content = ::std::option::Option::Some(Message_oneof_content::playerLeft(v))
    }

    // Mutable pointer to the field.
    pub fn mut_playerLeft(&mut self) -> &mut PlayerLeft {
        if let ::std::option::Option::Some(Message_oneof_content::playerLeft(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::playerLeft(PlayerLeft::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerLeft(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_playerLeft(&mut self) -> PlayerLeft {
        if self.has_playerLeft() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::playerLeft(v)) => v,
                _ => panic!(),
            }
        } else {
            PlayerLeft::new()
        }
    }

    // .superstellar.ProjectileFired projectileFired = 4;


    pub fn get_projectileFired(&self) -> &ProjectileFired {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileFired(ref v)) => v,
            _ => <ProjectileFired as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_projectileFired(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_projectileFired(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileFired(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_projectileFired(&mut self, v: ProjectileFired) {
        self.content = ::std::option::Option::Some(Message_oneof_content::projectileFired(v))
    }

    // Mutable pointer to the field.
    pub fn mut_projectileFired(&mut self) -> &mut ProjectileFired {
        if let ::std::option::Option::Some(Message_oneof_content::projectileFired(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::projectileFired(ProjectileFired::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileFired(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_projectileFired(&mut self) -> ProjectileFired {
        if self.has_projectileFired() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::projectileFired(v)) => v,
                _ => panic!(),
            }
        } else {
            ProjectileFired::new()
        }
    }

    // .superstellar.ProjectileHit projectileHit = 5;


    pub fn get_projectileHit(&self) -> &ProjectileHit {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileHit(ref v)) => v,
            _ => <ProjectileHit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_projectileHit(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_projectileHit(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileHit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_projectileHit(&mut self, v: ProjectileHit) {
        self.content = ::std::option::Option::Some(Message_oneof_content::projectileHit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_projectileHit(&mut self) -> &mut ProjectileHit {
        if let ::std::option::Option::Some(Message_oneof_content::projectileHit(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::projectileHit(ProjectileHit::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::projectileHit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_projectileHit(&mut self) -> ProjectileHit {
        if self.has_projectileHit() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::projectileHit(v)) => v,
                _ => panic!(),
            }
        } else {
            ProjectileHit::new()
        }
    }

    // .superstellar.PlayerJoined playerJoined = 6;


    pub fn get_playerJoined(&self) -> &PlayerJoined {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerJoined(ref v)) => v,
            _ => <PlayerJoined as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_playerJoined(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_playerJoined(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerJoined(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_playerJoined(&mut self, v: PlayerJoined) {
        self.content = ::std::option::Option::Some(Message_oneof_content::playerJoined(v))
    }

    // Mutable pointer to the field.
    pub fn mut_playerJoined(&mut self) -> &mut PlayerJoined {
        if let ::std::option::Option::Some(Message_oneof_content::playerJoined(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::playerJoined(PlayerJoined::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerJoined(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_playerJoined(&mut self) -> PlayerJoined {
        if self.has_playerJoined() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::playerJoined(v)) => v,
                _ => panic!(),
            }
        } else {
            PlayerJoined::new()
        }
    }

    // .superstellar.JoinGameAck joinGameAck = 7;


    pub fn get_joinGameAck(&self) -> &JoinGameAck {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::joinGameAck(ref v)) => v,
            _ => <JoinGameAck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_joinGameAck(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_joinGameAck(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::joinGameAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_joinGameAck(&mut self, v: JoinGameAck) {
        self.content = ::std::option::Option::Some(Message_oneof_content::joinGameAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_joinGameAck(&mut self) -> &mut JoinGameAck {
        if let ::std::option::Option::Some(Message_oneof_content::joinGameAck(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::joinGameAck(JoinGameAck::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::joinGameAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_joinGameAck(&mut self) -> JoinGameAck {
        if self.has_joinGameAck() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::joinGameAck(v)) => v,
                _ => panic!(),
            }
        } else {
            JoinGameAck::new()
        }
    }

    // .superstellar.Leaderboard leaderboard = 8;


    pub fn get_leaderboard(&self) -> &Leaderboard {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::leaderboard(ref v)) => v,
            _ => <Leaderboard as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_leaderboard(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_leaderboard(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::leaderboard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leaderboard(&mut self, v: Leaderboard) {
        self.content = ::std::option::Option::Some(Message_oneof_content::leaderboard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leaderboard(&mut self) -> &mut Leaderboard {
        if let ::std::option::Option::Some(Message_oneof_content::leaderboard(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::leaderboard(Leaderboard::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::leaderboard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leaderboard(&mut self) -> Leaderboard {
        if self.has_leaderboard() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::leaderboard(v)) => v,
                _ => panic!(),
            }
        } else {
            Leaderboard::new()
        }
    }

    // .superstellar.PlayerDied playerDied = 9;


    pub fn get_playerDied(&self) -> &PlayerDied {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerDied(ref v)) => v,
            _ => <PlayerDied as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_playerDied(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_playerDied(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerDied(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_playerDied(&mut self, v: PlayerDied) {
        self.content = ::std::option::Option::Some(Message_oneof_content::playerDied(v))
    }

    // Mutable pointer to the field.
    pub fn mut_playerDied(&mut self) -> &mut PlayerDied {
        if let ::std::option::Option::Some(Message_oneof_content::playerDied(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::playerDied(PlayerDied::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::playerDied(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_playerDied(&mut self) -> PlayerDied {
        if self.has_playerDied() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::playerDied(v)) => v,
                _ => panic!(),
            }
        } else {
            PlayerDied::new()
        }
    }

    // .superstellar.Pong pong = 10;


    pub fn get_pong(&self) -> &Pong {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pong(ref v)) => v,
            _ => <Pong as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pong(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_pong(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: Pong) {
        self.content = ::std::option::Option::Some(Message_oneof_content::pong(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pong(&mut self) -> &mut Pong {
        if let ::std::option::Option::Some(Message_oneof_content::pong(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::pong(Pong::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::pong(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pong(&mut self) -> Pong {
        if self.has_pong() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::pong(v)) => v,
                _ => panic!(),
            }
        } else {
            Pong::new()
        }
    }

    // .superstellar.ScoreBoard scoreBoard = 11;


    pub fn get_scoreBoard(&self) -> &ScoreBoard {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::scoreBoard(ref v)) => v,
            _ => <ScoreBoard as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_scoreBoard(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_scoreBoard(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::scoreBoard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scoreBoard(&mut self, v: ScoreBoard) {
        self.content = ::std::option::Option::Some(Message_oneof_content::scoreBoard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scoreBoard(&mut self) -> &mut ScoreBoard {
        if let ::std::option::Option::Some(Message_oneof_content::scoreBoard(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::scoreBoard(ScoreBoard::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::scoreBoard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scoreBoard(&mut self) -> ScoreBoard {
        if self.has_scoreBoard() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::scoreBoard(v)) => v,
                _ => panic!(),
            }
        } else {
            ScoreBoard::new()
        }
    }

    // .superstellar.Constants constants = 12;


    pub fn get_constants(&self) -> &Constants {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::constants(ref v)) => v,
            _ => <Constants as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_constants(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_constants(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::constants(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_constants(&mut self, v: Constants) {
        self.content = ::std::option::Option::Some(Message_oneof_content::constants(v))
    }

    // Mutable pointer to the field.
    pub fn mut_constants(&mut self) -> &mut Constants {
        if let ::std::option::Option::Some(Message_oneof_content::constants(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Message_oneof_content::constants(Constants::new()));
        }
        match self.content {
            ::std::option::Option::Some(Message_oneof_content::constants(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_constants(&mut self) -> Constants {
        if self.has_constants() {
            match self.content.take() {
                ::std::option::Option::Some(Message_oneof_content::constants(v)) => v,
                _ => panic!(),
            }
        } else {
            Constants::new()
        }
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        if let Some(Message_oneof_content::space(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::hello(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::playerLeft(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::projectileFired(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::projectileHit(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::playerJoined(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::joinGameAck(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::leaderboard(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::playerDied(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::pong(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::scoreBoard(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Message_oneof_content::constants(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::space(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::hello(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::playerLeft(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::projectileFired(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::projectileHit(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::playerJoined(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::joinGameAck(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::leaderboard(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::playerDied(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::pong(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::scoreBoard(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Message_oneof_content::constants(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::space(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::hello(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::playerLeft(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::projectileFired(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::projectileHit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::playerJoined(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::joinGameAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::leaderboard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::playerDied(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::pong(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::scoreBoard(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Message_oneof_content::constants(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Message_oneof_content::space(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::hello(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::playerLeft(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::projectileFired(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::projectileHit(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::playerJoined(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::joinGameAck(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::leaderboard(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::playerDied(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::pong(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::scoreBoard(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Message_oneof_content::constants(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Space>(
                "space",
                Message::has_space,
                Message::get_space,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Hello>(
                "hello",
                Message::has_hello,
                Message::get_hello,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlayerLeft>(
                "playerLeft",
                Message::has_playerLeft,
                Message::get_playerLeft,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProjectileFired>(
                "projectileFired",
                Message::has_projectileFired,
                Message::get_projectileFired,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProjectileHit>(
                "projectileHit",
                Message::has_projectileHit,
                Message::get_projectileHit,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlayerJoined>(
                "playerJoined",
                Message::has_playerJoined,
                Message::get_playerJoined,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JoinGameAck>(
                "joinGameAck",
                Message::has_joinGameAck,
                Message::get_joinGameAck,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Leaderboard>(
                "leaderboard",
                Message::has_leaderboard,
                Message::get_leaderboard,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlayerDied>(
                "playerDied",
                Message::has_playerDied,
                Message::get_playerDied,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pong>(
                "pong",
                Message::has_pong,
                Message::get_pong,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ScoreBoard>(
                "scoreBoard",
                Message::has_scoreBoard,
                Message::get_scoreBoard,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Constants>(
                "constants",
                Message::has_constants,
                Message::get_constants,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Message>(
                "Message",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Message {
        static instance: ::protobuf::rt::LazyV2<Message> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Message::new)
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point {
    // message fields
    pub x: i32,
    pub y: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // sint32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = v;
    }

    // sint32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = v;
    }
}

impl ::protobuf::Message for Point {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point {
        Point::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "x",
                |m: &Point| { &m.x },
                |m: &mut Point| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "y",
                |m: &Point| { &m.y },
                |m: &mut Point| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Point>(
                "Point",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Point {
        static instance: ::protobuf::rt::LazyV2<Point> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Point::new)
    }
}

impl ::protobuf::Clear for Point {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vector {
    // message fields
    pub x: f32,
    pub y: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector {
    fn default() -> &'a Vector {
        <Vector as ::protobuf::Message>::default_instance()
    }
}

impl Vector {
    pub fn new() -> Vector {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }
}

impl ::protobuf::Message for Vector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector {
        Vector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Vector| { &m.x },
                |m: &mut Vector| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Vector| { &m.y },
                |m: &mut Vector| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vector>(
                "Vector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vector {
        static instance: ::protobuf::rt::LazyV2<Vector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vector::new)
    }
}

impl ::protobuf::Clear for Vector {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Spaceship {
    // message fields
    pub id: u32,
    pub position: ::protobuf::SingularPtrField<Point>,
    pub velocity: ::protobuf::SingularPtrField<Vector>,
    pub facing: f64,
    pub angularVelocity: f64,
    pub inputDirection: Direction,
    pub inputThrust: bool,
    pub inputBoost: bool,
    pub maxHp: u32,
    pub hp: u32,
    pub maxEnergy: u32,
    pub energy: u32,
    pub autoRepairDelay: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Spaceship {
    fn default() -> &'a Spaceship {
        <Spaceship as ::protobuf::Message>::default_instance()
    }
}

impl Spaceship {
    pub fn new() -> Spaceship {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // .superstellar.Point position = 2;


    pub fn get_position(&self) -> &Point {
        self.position.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Point) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Point {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Point {
        self.position.take().unwrap_or_else(|| Point::new())
    }

    // .superstellar.Vector velocity = 3;


    pub fn get_velocity(&self) -> &Vector {
        self.velocity.as_ref().unwrap_or_else(|| <Vector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_velocity(&mut self) {
        self.velocity.clear();
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: Vector) {
        self.velocity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity(&mut self) -> &mut Vector {
        if self.velocity.is_none() {
            self.velocity.set_default();
        }
        self.velocity.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity(&mut self) -> Vector {
        self.velocity.take().unwrap_or_else(|| Vector::new())
    }

    // double facing = 4;


    pub fn get_facing(&self) -> f64 {
        self.facing
    }
    pub fn clear_facing(&mut self) {
        self.facing = 0.;
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: f64) {
        self.facing = v;
    }

    // double angularVelocity = 5;


    pub fn get_angularVelocity(&self) -> f64 {
        self.angularVelocity
    }
    pub fn clear_angularVelocity(&mut self) {
        self.angularVelocity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_angularVelocity(&mut self, v: f64) {
        self.angularVelocity = v;
    }

    // .superstellar.Direction inputDirection = 6;


    pub fn get_inputDirection(&self) -> Direction {
        self.inputDirection
    }
    pub fn clear_inputDirection(&mut self) {
        self.inputDirection = Direction::DIR_CENTER;
    }

    // Param is passed by value, moved
    pub fn set_inputDirection(&mut self, v: Direction) {
        self.inputDirection = v;
    }

    // bool inputThrust = 7;


    pub fn get_inputThrust(&self) -> bool {
        self.inputThrust
    }
    pub fn clear_inputThrust(&mut self) {
        self.inputThrust = false;
    }

    // Param is passed by value, moved
    pub fn set_inputThrust(&mut self, v: bool) {
        self.inputThrust = v;
    }

    // bool inputBoost = 8;


    pub fn get_inputBoost(&self) -> bool {
        self.inputBoost
    }
    pub fn clear_inputBoost(&mut self) {
        self.inputBoost = false;
    }

    // Param is passed by value, moved
    pub fn set_inputBoost(&mut self, v: bool) {
        self.inputBoost = v;
    }

    // uint32 maxHp = 9;


    pub fn get_maxHp(&self) -> u32 {
        self.maxHp
    }
    pub fn clear_maxHp(&mut self) {
        self.maxHp = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxHp(&mut self, v: u32) {
        self.maxHp = v;
    }

    // uint32 hp = 10;


    pub fn get_hp(&self) -> u32 {
        self.hp
    }
    pub fn clear_hp(&mut self) {
        self.hp = 0;
    }

    // Param is passed by value, moved
    pub fn set_hp(&mut self, v: u32) {
        self.hp = v;
    }

    // uint32 maxEnergy = 11;


    pub fn get_maxEnergy(&self) -> u32 {
        self.maxEnergy
    }
    pub fn clear_maxEnergy(&mut self) {
        self.maxEnergy = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxEnergy(&mut self, v: u32) {
        self.maxEnergy = v;
    }

    // uint32 energy = 12;


    pub fn get_energy(&self) -> u32 {
        self.energy
    }
    pub fn clear_energy(&mut self) {
        self.energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: u32) {
        self.energy = v;
    }

    // uint32 autoRepairDelay = 13;


    pub fn get_autoRepairDelay(&self) -> u32 {
        self.autoRepairDelay
    }
    pub fn clear_autoRepairDelay(&mut self) {
        self.autoRepairDelay = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoRepairDelay(&mut self, v: u32) {
        self.autoRepairDelay = v;
    }
}

impl ::protobuf::Message for Spaceship {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.velocity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.facing = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.angularVelocity = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.inputDirection, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inputThrust = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inputBoost = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxHp = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hp = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxEnergy = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.energy = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autoRepairDelay = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.facing != 0. {
            my_size += 9;
        }
        if self.angularVelocity != 0. {
            my_size += 9;
        }
        if self.inputDirection != Direction::DIR_CENTER {
            my_size += ::protobuf::rt::enum_size(6, self.inputDirection);
        }
        if self.inputThrust != false {
            my_size += 2;
        }
        if self.inputBoost != false {
            my_size += 2;
        }
        if self.maxHp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.maxHp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.hp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxEnergy != 0 {
            my_size += ::protobuf::rt::value_size(11, self.maxEnergy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.energy != 0 {
            my_size += ::protobuf::rt::value_size(12, self.energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoRepairDelay != 0 {
            my_size += ::protobuf::rt::value_size(13, self.autoRepairDelay, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.facing != 0. {
            os.write_double(4, self.facing)?;
        }
        if self.angularVelocity != 0. {
            os.write_double(5, self.angularVelocity)?;
        }
        if self.inputDirection != Direction::DIR_CENTER {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.inputDirection))?;
        }
        if self.inputThrust != false {
            os.write_bool(7, self.inputThrust)?;
        }
        if self.inputBoost != false {
            os.write_bool(8, self.inputBoost)?;
        }
        if self.maxHp != 0 {
            os.write_uint32(9, self.maxHp)?;
        }
        if self.hp != 0 {
            os.write_uint32(10, self.hp)?;
        }
        if self.maxEnergy != 0 {
            os.write_uint32(11, self.maxEnergy)?;
        }
        if self.energy != 0 {
            os.write_uint32(12, self.energy)?;
        }
        if self.autoRepairDelay != 0 {
            os.write_uint32(13, self.autoRepairDelay)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Spaceship {
        Spaceship::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Spaceship| { &m.id },
                |m: &mut Spaceship| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "position",
                |m: &Spaceship| { &m.position },
                |m: &mut Spaceship| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector>>(
                "velocity",
                |m: &Spaceship| { &m.velocity },
                |m: &mut Spaceship| { &mut m.velocity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "facing",
                |m: &Spaceship| { &m.facing },
                |m: &mut Spaceship| { &mut m.facing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "angularVelocity",
                |m: &Spaceship| { &m.angularVelocity },
                |m: &mut Spaceship| { &mut m.angularVelocity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                "inputDirection",
                |m: &Spaceship| { &m.inputDirection },
                |m: &mut Spaceship| { &mut m.inputDirection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inputThrust",
                |m: &Spaceship| { &m.inputThrust },
                |m: &mut Spaceship| { &mut m.inputThrust },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inputBoost",
                |m: &Spaceship| { &m.inputBoost },
                |m: &mut Spaceship| { &mut m.inputBoost },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maxHp",
                |m: &Spaceship| { &m.maxHp },
                |m: &mut Spaceship| { &mut m.maxHp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hp",
                |m: &Spaceship| { &m.hp },
                |m: &mut Spaceship| { &mut m.hp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maxEnergy",
                |m: &Spaceship| { &m.maxEnergy },
                |m: &mut Spaceship| { &mut m.maxEnergy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "energy",
                |m: &Spaceship| { &m.energy },
                |m: &mut Spaceship| { &mut m.energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "autoRepairDelay",
                |m: &Spaceship| { &m.autoRepairDelay },
                |m: &mut Spaceship| { &mut m.autoRepairDelay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Spaceship>(
                "Spaceship",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Spaceship {
        static instance: ::protobuf::rt::LazyV2<Spaceship> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Spaceship::new)
    }
}

impl ::protobuf::Clear for Spaceship {
    fn clear(&mut self) {
        self.id = 0;
        self.position.clear();
        self.velocity.clear();
        self.facing = 0.;
        self.angularVelocity = 0.;
        self.inputDirection = Direction::DIR_CENTER;
        self.inputThrust = false;
        self.inputBoost = false;
        self.maxHp = 0;
        self.hp = 0;
        self.maxEnergy = 0;
        self.energy = 0;
        self.autoRepairDelay = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Spaceship {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Spaceship {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asteroid {
    // message fields
    pub id: u32,
    pub position: ::protobuf::SingularPtrField<Point>,
    pub velocity: ::protobuf::SingularPtrField<Vector>,
    pub facing: f64,
    pub angularVelocity: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asteroid {
    fn default() -> &'a Asteroid {
        <Asteroid as ::protobuf::Message>::default_instance()
    }
}

impl Asteroid {
    pub fn new() -> Asteroid {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // .superstellar.Point position = 2;


    pub fn get_position(&self) -> &Point {
        self.position.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Point) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Point {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Point {
        self.position.take().unwrap_or_else(|| Point::new())
    }

    // .superstellar.Vector velocity = 3;


    pub fn get_velocity(&self) -> &Vector {
        self.velocity.as_ref().unwrap_or_else(|| <Vector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_velocity(&mut self) {
        self.velocity.clear();
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: Vector) {
        self.velocity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity(&mut self) -> &mut Vector {
        if self.velocity.is_none() {
            self.velocity.set_default();
        }
        self.velocity.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity(&mut self) -> Vector {
        self.velocity.take().unwrap_or_else(|| Vector::new())
    }

    // double facing = 4;


    pub fn get_facing(&self) -> f64 {
        self.facing
    }
    pub fn clear_facing(&mut self) {
        self.facing = 0.;
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: f64) {
        self.facing = v;
    }

    // double angularVelocity = 5;


    pub fn get_angularVelocity(&self) -> f64 {
        self.angularVelocity
    }
    pub fn clear_angularVelocity(&mut self) {
        self.angularVelocity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_angularVelocity(&mut self, v: f64) {
        self.angularVelocity = v;
    }
}

impl ::protobuf::Message for Asteroid {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.velocity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.facing = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.angularVelocity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.facing != 0. {
            my_size += 9;
        }
        if self.angularVelocity != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.facing != 0. {
            os.write_double(4, self.facing)?;
        }
        if self.angularVelocity != 0. {
            os.write_double(5, self.angularVelocity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asteroid {
        Asteroid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Asteroid| { &m.id },
                |m: &mut Asteroid| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "position",
                |m: &Asteroid| { &m.position },
                |m: &mut Asteroid| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector>>(
                "velocity",
                |m: &Asteroid| { &m.velocity },
                |m: &mut Asteroid| { &mut m.velocity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "facing",
                |m: &Asteroid| { &m.facing },
                |m: &mut Asteroid| { &mut m.facing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "angularVelocity",
                |m: &Asteroid| { &m.angularVelocity },
                |m: &mut Asteroid| { &mut m.angularVelocity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Asteroid>(
                "Asteroid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Asteroid {
        static instance: ::protobuf::rt::LazyV2<Asteroid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Asteroid::new)
    }
}

impl ::protobuf::Clear for Asteroid {
    fn clear(&mut self) {
        self.id = 0;
        self.position.clear();
        self.velocity.clear();
        self.facing = 0.;
        self.angularVelocity = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asteroid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asteroid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProjectileFired {
    // message fields
    pub id: u32,
    pub frameId: u32,
    pub origin: ::protobuf::SingularPtrField<Point>,
    pub velocity: ::protobuf::SingularPtrField<Vector>,
    pub facing: f32,
    pub ttl: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProjectileFired {
    fn default() -> &'a ProjectileFired {
        <ProjectileFired as ::protobuf::Message>::default_instance()
    }
}

impl ProjectileFired {
    pub fn new() -> ProjectileFired {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // uint32 frameId = 2;


    pub fn get_frameId(&self) -> u32 {
        self.frameId
    }
    pub fn clear_frameId(&mut self) {
        self.frameId = 0;
    }

    // Param is passed by value, moved
    pub fn set_frameId(&mut self, v: u32) {
        self.frameId = v;
    }

    // .superstellar.Point origin = 3;


    pub fn get_origin(&self) -> &Point {
        self.origin.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: Point) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut Point {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> Point {
        self.origin.take().unwrap_or_else(|| Point::new())
    }

    // .superstellar.Vector velocity = 4;


    pub fn get_velocity(&self) -> &Vector {
        self.velocity.as_ref().unwrap_or_else(|| <Vector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_velocity(&mut self) {
        self.velocity.clear();
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: Vector) {
        self.velocity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity(&mut self) -> &mut Vector {
        if self.velocity.is_none() {
            self.velocity.set_default();
        }
        self.velocity.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity(&mut self) -> Vector {
        self.velocity.take().unwrap_or_else(|| Vector::new())
    }

    // float facing = 5;


    pub fn get_facing(&self) -> f32 {
        self.facing
    }
    pub fn clear_facing(&mut self) {
        self.facing = 0.;
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: f32) {
        self.facing = v;
    }

    // uint32 ttl = 6;


    pub fn get_ttl(&self) -> u32 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u32) {
        self.ttl = v;
    }
}

impl ::protobuf::Message for ProjectileFired {
    fn is_initialized(&self) -> bool {
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.velocity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frameId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.facing = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ttl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frameId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frameId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.facing != 0. {
            my_size += 5;
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(6, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.frameId != 0 {
            os.write_uint32(2, self.frameId)?;
        }
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.facing != 0. {
            os.write_float(5, self.facing)?;
        }
        if self.ttl != 0 {
            os.write_uint32(6, self.ttl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProjectileFired {
        ProjectileFired::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &ProjectileFired| { &m.id },
                |m: &mut ProjectileFired| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frameId",
                |m: &ProjectileFired| { &m.frameId },
                |m: &mut ProjectileFired| { &mut m.frameId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "origin",
                |m: &ProjectileFired| { &m.origin },
                |m: &mut ProjectileFired| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector>>(
                "velocity",
                |m: &ProjectileFired| { &m.velocity },
                |m: &mut ProjectileFired| { &mut m.velocity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "facing",
                |m: &ProjectileFired| { &m.facing },
                |m: &mut ProjectileFired| { &mut m.facing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ttl",
                |m: &ProjectileFired| { &m.ttl },
                |m: &mut ProjectileFired| { &mut m.ttl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProjectileFired>(
                "ProjectileFired",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProjectileFired {
        static instance: ::protobuf::rt::LazyV2<ProjectileFired> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProjectileFired::new)
    }
}

impl ::protobuf::Clear for ProjectileFired {
    fn clear(&mut self) {
        self.id = 0;
        self.frameId = 0;
        self.origin.clear();
        self.velocity.clear();
        self.facing = 0.;
        self.ttl = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProjectileFired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectileFired {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProjectileHit {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProjectileHit {
    fn default() -> &'a ProjectileHit {
        <ProjectileHit as ::protobuf::Message>::default_instance()
    }
}

impl ProjectileHit {
    pub fn new() -> ProjectileHit {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for ProjectileHit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProjectileHit {
        ProjectileHit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &ProjectileHit| { &m.id },
                |m: &mut ProjectileHit| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProjectileHit>(
                "ProjectileHit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProjectileHit {
        static instance: ::protobuf::rt::LazyV2<ProjectileHit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProjectileHit::new)
    }
}

impl ::protobuf::Clear for ProjectileHit {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProjectileHit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectileHit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerLeft {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerLeft {
    fn default() -> &'a PlayerLeft {
        <PlayerLeft as ::protobuf::Message>::default_instance()
    }
}

impl PlayerLeft {
    pub fn new() -> PlayerLeft {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for PlayerLeft {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerLeft {
        PlayerLeft::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &PlayerLeft| { &m.id },
                |m: &mut PlayerLeft| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerLeft>(
                "PlayerLeft",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerLeft {
        static instance: ::protobuf::rt::LazyV2<PlayerLeft> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerLeft::new)
    }
}

impl ::protobuf::Clear for PlayerLeft {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerLeft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerLeft {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerJoined {
    // message fields
    pub id: u32,
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerJoined {
    fn default() -> &'a PlayerJoined {
        <PlayerJoined as ::protobuf::Message>::default_instance()
    }
}

impl PlayerJoined {
    pub fn new() -> PlayerJoined {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string username = 2;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PlayerJoined {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerJoined {
        PlayerJoined::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &PlayerJoined| { &m.id },
                |m: &mut PlayerJoined| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &PlayerJoined| { &m.username },
                |m: &mut PlayerJoined| { &mut m.username },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerJoined>(
                "PlayerJoined",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerJoined {
        static instance: ::protobuf::rt::LazyV2<PlayerJoined> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerJoined::new)
    }
}

impl ::protobuf::Clear for PlayerJoined {
    fn clear(&mut self) {
        self.id = 0;
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerJoined {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerJoined {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerDied {
    // message fields
    pub id: u32,
    pub killedBy: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerDied {
    fn default() -> &'a PlayerDied {
        <PlayerDied as ::protobuf::Message>::default_instance()
    }
}

impl PlayerDied {
    pub fn new() -> PlayerDied {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // uint32 killedBy = 2;


    pub fn get_killedBy(&self) -> u32 {
        self.killedBy
    }
    pub fn clear_killedBy(&mut self) {
        self.killedBy = 0;
    }

    // Param is passed by value, moved
    pub fn set_killedBy(&mut self, v: u32) {
        self.killedBy = v;
    }
}

impl ::protobuf::Message for PlayerDied {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killedBy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.killedBy != 0 {
            my_size += ::protobuf::rt::value_size(2, self.killedBy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.killedBy != 0 {
            os.write_uint32(2, self.killedBy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerDied {
        PlayerDied::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &PlayerDied| { &m.id },
                |m: &mut PlayerDied| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "killedBy",
                |m: &PlayerDied| { &m.killedBy },
                |m: &mut PlayerDied| { &mut m.killedBy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayerDied>(
                "PlayerDied",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayerDied {
        static instance: ::protobuf::rt::LazyV2<PlayerDied> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayerDied::new)
    }
}

impl ::protobuf::Clear for PlayerDied {
    fn clear(&mut self) {
        self.id = 0;
        self.killedBy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerDied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerDied {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // message fields
    pub Id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    // uint32 Id = 1;


    pub fn get_Id(&self) -> u32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: u32) {
        self.Id = v;
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_uint32(1, self.Id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Id",
                |m: &Ping| { &m.Id },
                |m: &mut Ping| { &mut m.Id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ping>(
                "Ping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ping {
        static instance: ::protobuf::rt::LazyV2<Ping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ping::new)
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.Id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pong {
    // message fields
    pub Id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pong {
    fn default() -> &'a Pong {
        <Pong as ::protobuf::Message>::default_instance()
    }
}

impl Pong {
    pub fn new() -> Pong {
        ::std::default::Default::default()
    }

    // uint32 Id = 1;


    pub fn get_Id(&self) -> u32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: u32) {
        self.Id = v;
    }
}

impl ::protobuf::Message for Pong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_uint32(1, self.Id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pong {
        Pong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Id",
                |m: &Pong| { &m.Id },
                |m: &mut Pong| { &mut m.Id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pong>(
                "Pong",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pong {
        static instance: ::protobuf::rt::LazyV2<Pong> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pong::new)
    }
}

impl ::protobuf::Clear for Pong {
    fn clear(&mut self) {
        self.Id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Space {
    // message fields
    pub physicsFrameID: u32,
    pub spaceships: ::protobuf::RepeatedField<Spaceship>,
    pub asteroids: ::protobuf::RepeatedField<Asteroid>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Space {
    fn default() -> &'a Space {
        <Space as ::protobuf::Message>::default_instance()
    }
}

impl Space {
    pub fn new() -> Space {
        ::std::default::Default::default()
    }

    // uint32 physicsFrameID = 1;


    pub fn get_physicsFrameID(&self) -> u32 {
        self.physicsFrameID
    }
    pub fn clear_physicsFrameID(&mut self) {
        self.physicsFrameID = 0;
    }

    // Param is passed by value, moved
    pub fn set_physicsFrameID(&mut self, v: u32) {
        self.physicsFrameID = v;
    }

    // repeated .superstellar.Spaceship spaceships = 2;


    pub fn get_spaceships(&self) -> &[Spaceship] {
        &self.spaceships
    }
    pub fn clear_spaceships(&mut self) {
        self.spaceships.clear();
    }

    // Param is passed by value, moved
    pub fn set_spaceships(&mut self, v: ::protobuf::RepeatedField<Spaceship>) {
        self.spaceships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spaceships(&mut self) -> &mut ::protobuf::RepeatedField<Spaceship> {
        &mut self.spaceships
    }

    // Take field
    pub fn take_spaceships(&mut self) -> ::protobuf::RepeatedField<Spaceship> {
        ::std::mem::replace(&mut self.spaceships, ::protobuf::RepeatedField::new())
    }

    // repeated .superstellar.Asteroid asteroids = 3;


    pub fn get_asteroids(&self) -> &[Asteroid] {
        &self.asteroids
    }
    pub fn clear_asteroids(&mut self) {
        self.asteroids.clear();
    }

    // Param is passed by value, moved
    pub fn set_asteroids(&mut self, v: ::protobuf::RepeatedField<Asteroid>) {
        self.asteroids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asteroids(&mut self) -> &mut ::protobuf::RepeatedField<Asteroid> {
        &mut self.asteroids
    }

    // Take field
    pub fn take_asteroids(&mut self) -> ::protobuf::RepeatedField<Asteroid> {
        ::std::mem::replace(&mut self.asteroids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Space {
    fn is_initialized(&self) -> bool {
        for v in &self.spaceships {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.asteroids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.physicsFrameID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spaceships)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.asteroids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.physicsFrameID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.physicsFrameID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.spaceships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.asteroids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.physicsFrameID != 0 {
            os.write_uint32(1, self.physicsFrameID)?;
        }
        for v in &self.spaceships {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.asteroids {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Space {
        Space::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "physicsFrameID",
                |m: &Space| { &m.physicsFrameID },
                |m: &mut Space| { &mut m.physicsFrameID },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Spaceship>>(
                "spaceships",
                |m: &Space| { &m.spaceships },
                |m: &mut Space| { &mut m.spaceships },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asteroid>>(
                "asteroids",
                |m: &Space| { &m.asteroids },
                |m: &mut Space| { &mut m.asteroids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Space>(
                "Space",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Space {
        static instance: ::protobuf::rt::LazyV2<Space> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Space::new)
    }
}

impl ::protobuf::Clear for Space {
    fn clear(&mut self) {
        self.physicsFrameID = 0;
        self.spaceships.clear();
        self.asteroids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Space {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Space {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hello {
    // message fields
    pub myId: u32,
    pub idToUsername: ::std::collections::HashMap<u32, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hello {
    fn default() -> &'a Hello {
        <Hello as ::protobuf::Message>::default_instance()
    }
}

impl Hello {
    pub fn new() -> Hello {
        ::std::default::Default::default()
    }

    // uint32 myId = 1;


    pub fn get_myId(&self) -> u32 {
        self.myId
    }
    pub fn clear_myId(&mut self) {
        self.myId = 0;
    }

    // Param is passed by value, moved
    pub fn set_myId(&mut self, v: u32) {
        self.myId = v;
    }

    // repeated .superstellar.Hello.IdToUsernameEntry idToUsername = 2;


    pub fn get_idToUsername(&self) -> &::std::collections::HashMap<u32, ::std::string::String> {
        &self.idToUsername
    }
    pub fn clear_idToUsername(&mut self) {
        self.idToUsername.clear();
    }

    // Param is passed by value, moved
    pub fn set_idToUsername(&mut self, v: ::std::collections::HashMap<u32, ::std::string::String>) {
        self.idToUsername = v;
    }

    // Mutable pointer to the field.
    pub fn mut_idToUsername(&mut self) -> &mut ::std::collections::HashMap<u32, ::std::string::String> {
        &mut self.idToUsername
    }

    // Take field
    pub fn take_idToUsername(&mut self) -> ::std::collections::HashMap<u32, ::std::string::String> {
        ::std::mem::replace(&mut self.idToUsername, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Hello {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.myId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.idToUsername)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.myId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.myId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeString>(2, &self.idToUsername);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.myId != 0 {
            os.write_uint32(1, self.myId)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeString>(2, &self.idToUsername, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hello {
        Hello::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "myId",
                |m: &Hello| { &m.myId },
                |m: &mut Hello| { &mut m.myId },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeString>(
                "idToUsername",
                |m: &Hello| { &m.idToUsername },
                |m: &mut Hello| { &mut m.idToUsername },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hello>(
                "Hello",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Hello {
        static instance: ::protobuf::rt::LazyV2<Hello> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Hello::new)
    }
}

impl ::protobuf::Clear for Hello {
    fn clear(&mut self) {
        self.myId = 0;
        self.idToUsername.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hello {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Constants {
    // message fields
    pub worldRadius: f32,
    pub boundaryAnnulusWidth: f32,
    pub spaceshipAcceleration: f32,
    pub frictionCoefficient: f32,
    pub spaceshipNonlinearAngularAcceleration: f32,
    pub spaceshipLinearAngularAcceleration: f32,
    pub spaceshipMaxAngularVelocity: f32,
    pub spaceshipAngularFriction: f32,
    pub spaceshipMaxSpeed: u32,
    pub spaceshipBoostFactor: f32,
    pub autoRepairInterval: u32,
    pub autoRepairAmount: u32,
    pub autoEnergyRechargeAmount: u32,
    pub boostPerFrameEnergyCost: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Constants {
    fn default() -> &'a Constants {
        <Constants as ::protobuf::Message>::default_instance()
    }
}

impl Constants {
    pub fn new() -> Constants {
        ::std::default::Default::default()
    }

    // float worldRadius = 1;


    pub fn get_worldRadius(&self) -> f32 {
        self.worldRadius
    }
    pub fn clear_worldRadius(&mut self) {
        self.worldRadius = 0.;
    }

    // Param is passed by value, moved
    pub fn set_worldRadius(&mut self, v: f32) {
        self.worldRadius = v;
    }

    // float boundaryAnnulusWidth = 2;


    pub fn get_boundaryAnnulusWidth(&self) -> f32 {
        self.boundaryAnnulusWidth
    }
    pub fn clear_boundaryAnnulusWidth(&mut self) {
        self.boundaryAnnulusWidth = 0.;
    }

    // Param is passed by value, moved
    pub fn set_boundaryAnnulusWidth(&mut self, v: f32) {
        self.boundaryAnnulusWidth = v;
    }

    // float spaceshipAcceleration = 3;


    pub fn get_spaceshipAcceleration(&self) -> f32 {
        self.spaceshipAcceleration
    }
    pub fn clear_spaceshipAcceleration(&mut self) {
        self.spaceshipAcceleration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipAcceleration(&mut self, v: f32) {
        self.spaceshipAcceleration = v;
    }

    // float frictionCoefficient = 4;


    pub fn get_frictionCoefficient(&self) -> f32 {
        self.frictionCoefficient
    }
    pub fn clear_frictionCoefficient(&mut self) {
        self.frictionCoefficient = 0.;
    }

    // Param is passed by value, moved
    pub fn set_frictionCoefficient(&mut self, v: f32) {
        self.frictionCoefficient = v;
    }

    // float spaceshipNonlinearAngularAcceleration = 5;


    pub fn get_spaceshipNonlinearAngularAcceleration(&self) -> f32 {
        self.spaceshipNonlinearAngularAcceleration
    }
    pub fn clear_spaceshipNonlinearAngularAcceleration(&mut self) {
        self.spaceshipNonlinearAngularAcceleration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipNonlinearAngularAcceleration(&mut self, v: f32) {
        self.spaceshipNonlinearAngularAcceleration = v;
    }

    // float spaceshipLinearAngularAcceleration = 6;


    pub fn get_spaceshipLinearAngularAcceleration(&self) -> f32 {
        self.spaceshipLinearAngularAcceleration
    }
    pub fn clear_spaceshipLinearAngularAcceleration(&mut self) {
        self.spaceshipLinearAngularAcceleration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipLinearAngularAcceleration(&mut self, v: f32) {
        self.spaceshipLinearAngularAcceleration = v;
    }

    // float spaceshipMaxAngularVelocity = 7;


    pub fn get_spaceshipMaxAngularVelocity(&self) -> f32 {
        self.spaceshipMaxAngularVelocity
    }
    pub fn clear_spaceshipMaxAngularVelocity(&mut self) {
        self.spaceshipMaxAngularVelocity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipMaxAngularVelocity(&mut self, v: f32) {
        self.spaceshipMaxAngularVelocity = v;
    }

    // float spaceshipAngularFriction = 8;


    pub fn get_spaceshipAngularFriction(&self) -> f32 {
        self.spaceshipAngularFriction
    }
    pub fn clear_spaceshipAngularFriction(&mut self) {
        self.spaceshipAngularFriction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipAngularFriction(&mut self, v: f32) {
        self.spaceshipAngularFriction = v;
    }

    // uint32 spaceshipMaxSpeed = 9;


    pub fn get_spaceshipMaxSpeed(&self) -> u32 {
        self.spaceshipMaxSpeed
    }
    pub fn clear_spaceshipMaxSpeed(&mut self) {
        self.spaceshipMaxSpeed = 0;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipMaxSpeed(&mut self, v: u32) {
        self.spaceshipMaxSpeed = v;
    }

    // float spaceshipBoostFactor = 10;


    pub fn get_spaceshipBoostFactor(&self) -> f32 {
        self.spaceshipBoostFactor
    }
    pub fn clear_spaceshipBoostFactor(&mut self) {
        self.spaceshipBoostFactor = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spaceshipBoostFactor(&mut self, v: f32) {
        self.spaceshipBoostFactor = v;
    }

    // uint32 autoRepairInterval = 11;


    pub fn get_autoRepairInterval(&self) -> u32 {
        self.autoRepairInterval
    }
    pub fn clear_autoRepairInterval(&mut self) {
        self.autoRepairInterval = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoRepairInterval(&mut self, v: u32) {
        self.autoRepairInterval = v;
    }

    // uint32 autoRepairAmount = 12;


    pub fn get_autoRepairAmount(&self) -> u32 {
        self.autoRepairAmount
    }
    pub fn clear_autoRepairAmount(&mut self) {
        self.autoRepairAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoRepairAmount(&mut self, v: u32) {
        self.autoRepairAmount = v;
    }

    // uint32 autoEnergyRechargeAmount = 13;


    pub fn get_autoEnergyRechargeAmount(&self) -> u32 {
        self.autoEnergyRechargeAmount
    }
    pub fn clear_autoEnergyRechargeAmount(&mut self) {
        self.autoEnergyRechargeAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_autoEnergyRechargeAmount(&mut self, v: u32) {
        self.autoEnergyRechargeAmount = v;
    }

    // uint32 boostPerFrameEnergyCost = 14;


    pub fn get_boostPerFrameEnergyCost(&self) -> u32 {
        self.boostPerFrameEnergyCost
    }
    pub fn clear_boostPerFrameEnergyCost(&mut self) {
        self.boostPerFrameEnergyCost = 0;
    }

    // Param is passed by value, moved
    pub fn set_boostPerFrameEnergyCost(&mut self, v: u32) {
        self.boostPerFrameEnergyCost = v;
    }
}

impl ::protobuf::Message for Constants {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.worldRadius = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.boundaryAnnulusWidth = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipAcceleration = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frictionCoefficient = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipNonlinearAngularAcceleration = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipLinearAngularAcceleration = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipMaxAngularVelocity = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipAngularFriction = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spaceshipMaxSpeed = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.spaceshipBoostFactor = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autoRepairInterval = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autoRepairAmount = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autoEnergyRechargeAmount = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.boostPerFrameEnergyCost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.worldRadius != 0. {
            my_size += 5;
        }
        if self.boundaryAnnulusWidth != 0. {
            my_size += 5;
        }
        if self.spaceshipAcceleration != 0. {
            my_size += 5;
        }
        if self.frictionCoefficient != 0. {
            my_size += 5;
        }
        if self.spaceshipNonlinearAngularAcceleration != 0. {
            my_size += 5;
        }
        if self.spaceshipLinearAngularAcceleration != 0. {
            my_size += 5;
        }
        if self.spaceshipMaxAngularVelocity != 0. {
            my_size += 5;
        }
        if self.spaceshipAngularFriction != 0. {
            my_size += 5;
        }
        if self.spaceshipMaxSpeed != 0 {
            my_size += ::protobuf::rt::value_size(9, self.spaceshipMaxSpeed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spaceshipBoostFactor != 0. {
            my_size += 5;
        }
        if self.autoRepairInterval != 0 {
            my_size += ::protobuf::rt::value_size(11, self.autoRepairInterval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoRepairAmount != 0 {
            my_size += ::protobuf::rt::value_size(12, self.autoRepairAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoEnergyRechargeAmount != 0 {
            my_size += ::protobuf::rt::value_size(13, self.autoEnergyRechargeAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.boostPerFrameEnergyCost != 0 {
            my_size += ::protobuf::rt::value_size(14, self.boostPerFrameEnergyCost, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.worldRadius != 0. {
            os.write_float(1, self.worldRadius)?;
        }
        if self.boundaryAnnulusWidth != 0. {
            os.write_float(2, self.boundaryAnnulusWidth)?;
        }
        if self.spaceshipAcceleration != 0. {
            os.write_float(3, self.spaceshipAcceleration)?;
        }
        if self.frictionCoefficient != 0. {
            os.write_float(4, self.frictionCoefficient)?;
        }
        if self.spaceshipNonlinearAngularAcceleration != 0. {
            os.write_float(5, self.spaceshipNonlinearAngularAcceleration)?;
        }
        if self.spaceshipLinearAngularAcceleration != 0. {
            os.write_float(6, self.spaceshipLinearAngularAcceleration)?;
        }
        if self.spaceshipMaxAngularVelocity != 0. {
            os.write_float(7, self.spaceshipMaxAngularVelocity)?;
        }
        if self.spaceshipAngularFriction != 0. {
            os.write_float(8, self.spaceshipAngularFriction)?;
        }
        if self.spaceshipMaxSpeed != 0 {
            os.write_uint32(9, self.spaceshipMaxSpeed)?;
        }
        if self.spaceshipBoostFactor != 0. {
            os.write_float(10, self.spaceshipBoostFactor)?;
        }
        if self.autoRepairInterval != 0 {
            os.write_uint32(11, self.autoRepairInterval)?;
        }
        if self.autoRepairAmount != 0 {
            os.write_uint32(12, self.autoRepairAmount)?;
        }
        if self.autoEnergyRechargeAmount != 0 {
            os.write_uint32(13, self.autoEnergyRechargeAmount)?;
        }
        if self.boostPerFrameEnergyCost != 0 {
            os.write_uint32(14, self.boostPerFrameEnergyCost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Constants {
        Constants::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "worldRadius",
                |m: &Constants| { &m.worldRadius },
                |m: &mut Constants| { &mut m.worldRadius },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "boundaryAnnulusWidth",
                |m: &Constants| { &m.boundaryAnnulusWidth },
                |m: &mut Constants| { &mut m.boundaryAnnulusWidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipAcceleration",
                |m: &Constants| { &m.spaceshipAcceleration },
                |m: &mut Constants| { &mut m.spaceshipAcceleration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "frictionCoefficient",
                |m: &Constants| { &m.frictionCoefficient },
                |m: &mut Constants| { &mut m.frictionCoefficient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipNonlinearAngularAcceleration",
                |m: &Constants| { &m.spaceshipNonlinearAngularAcceleration },
                |m: &mut Constants| { &mut m.spaceshipNonlinearAngularAcceleration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipLinearAngularAcceleration",
                |m: &Constants| { &m.spaceshipLinearAngularAcceleration },
                |m: &mut Constants| { &mut m.spaceshipLinearAngularAcceleration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipMaxAngularVelocity",
                |m: &Constants| { &m.spaceshipMaxAngularVelocity },
                |m: &mut Constants| { &mut m.spaceshipMaxAngularVelocity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipAngularFriction",
                |m: &Constants| { &m.spaceshipAngularFriction },
                |m: &mut Constants| { &mut m.spaceshipAngularFriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "spaceshipMaxSpeed",
                |m: &Constants| { &m.spaceshipMaxSpeed },
                |m: &mut Constants| { &mut m.spaceshipMaxSpeed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "spaceshipBoostFactor",
                |m: &Constants| { &m.spaceshipBoostFactor },
                |m: &mut Constants| { &mut m.spaceshipBoostFactor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "autoRepairInterval",
                |m: &Constants| { &m.autoRepairInterval },
                |m: &mut Constants| { &mut m.autoRepairInterval },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "autoRepairAmount",
                |m: &Constants| { &m.autoRepairAmount },
                |m: &mut Constants| { &mut m.autoRepairAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "autoEnergyRechargeAmount",
                |m: &Constants| { &m.autoEnergyRechargeAmount },
                |m: &mut Constants| { &mut m.autoEnergyRechargeAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "boostPerFrameEnergyCost",
                |m: &Constants| { &m.boostPerFrameEnergyCost },
                |m: &mut Constants| { &mut m.boostPerFrameEnergyCost },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Constants>(
                "Constants",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Constants {
        static instance: ::protobuf::rt::LazyV2<Constants> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Constants::new)
    }
}

impl ::protobuf::Clear for Constants {
    fn clear(&mut self) {
        self.worldRadius = 0.;
        self.boundaryAnnulusWidth = 0.;
        self.spaceshipAcceleration = 0.;
        self.frictionCoefficient = 0.;
        self.spaceshipNonlinearAngularAcceleration = 0.;
        self.spaceshipLinearAngularAcceleration = 0.;
        self.spaceshipMaxAngularVelocity = 0.;
        self.spaceshipAngularFriction = 0.;
        self.spaceshipMaxSpeed = 0;
        self.spaceshipBoostFactor = 0.;
        self.autoRepairInterval = 0;
        self.autoRepairAmount = 0;
        self.autoEnergyRechargeAmount = 0;
        self.boostPerFrameEnergyCost = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Constants {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Constants {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JoinGame {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JoinGame {
    fn default() -> &'a JoinGame {
        <JoinGame as ::protobuf::Message>::default_instance()
    }
}

impl JoinGame {
    pub fn new() -> JoinGame {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JoinGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JoinGame {
        JoinGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &JoinGame| { &m.username },
                |m: &mut JoinGame| { &mut m.username },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JoinGame>(
                "JoinGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JoinGame {
        static instance: ::protobuf::rt::LazyV2<JoinGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JoinGame::new)
    }
}

impl ::protobuf::Clear for JoinGame {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JoinGameAck {
    // message fields
    pub success: bool,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JoinGameAck {
    fn default() -> &'a JoinGameAck {
        <JoinGameAck as ::protobuf::Message>::default_instance()
    }
}

impl JoinGameAck {
    pub fn new() -> JoinGameAck {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JoinGameAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JoinGameAck {
        JoinGameAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &JoinGameAck| { &m.success },
                |m: &mut JoinGameAck| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &JoinGameAck| { &m.error },
                |m: &mut JoinGameAck| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JoinGameAck>(
                "JoinGameAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JoinGameAck {
        static instance: ::protobuf::rt::LazyV2<JoinGameAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JoinGameAck::new)
    }
}

impl ::protobuf::Clear for JoinGameAck {
    fn clear(&mut self) {
        self.success = false;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JoinGameAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JoinGameAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAction {
    // message fields
    pub userInput: UserInput,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAction {
    fn default() -> &'a UserAction {
        <UserAction as ::protobuf::Message>::default_instance()
    }
}

impl UserAction {
    pub fn new() -> UserAction {
        ::std::default::Default::default()
    }

    // .superstellar.UserInput userInput = 1;


    pub fn get_userInput(&self) -> UserInput {
        self.userInput
    }
    pub fn clear_userInput(&mut self) {
        self.userInput = UserInput::CENTER;
    }

    // Param is passed by value, moved
    pub fn set_userInput(&mut self, v: UserInput) {
        self.userInput = v;
    }
}

impl ::protobuf::Message for UserAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.userInput, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.userInput != UserInput::CENTER {
            my_size += ::protobuf::rt::enum_size(1, self.userInput);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.userInput != UserInput::CENTER {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.userInput))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAction {
        UserAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserInput>>(
                "userInput",
                |m: &UserAction| { &m.userInput },
                |m: &mut UserAction| { &mut m.userInput },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAction>(
                "UserAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserAction {
        static instance: ::protobuf::rt::LazyV2<UserAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserAction::new)
    }
}

impl ::protobuf::Clear for UserAction {
    fn clear(&mut self) {
        self.userInput = UserInput::CENTER;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetAngle {
    // message fields
    pub angle: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TargetAngle {
    fn default() -> &'a TargetAngle {
        <TargetAngle as ::protobuf::Message>::default_instance()
    }
}

impl TargetAngle {
    pub fn new() -> TargetAngle {
        ::std::default::Default::default()
    }

    // float angle = 1;


    pub fn get_angle(&self) -> f32 {
        self.angle
    }
    pub fn clear_angle(&mut self) {
        self.angle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_angle(&mut self, v: f32) {
        self.angle = v;
    }
}

impl ::protobuf::Message for TargetAngle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.angle = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.angle != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.angle != 0. {
            os.write_float(1, self.angle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TargetAngle {
        TargetAngle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "angle",
                |m: &TargetAngle| { &m.angle },
                |m: &mut TargetAngle| { &mut m.angle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TargetAngle>(
                "TargetAngle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TargetAngle {
        static instance: ::protobuf::rt::LazyV2<TargetAngle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TargetAngle::new)
    }
}

impl ::protobuf::Clear for TargetAngle {
    fn clear(&mut self) {
        self.angle = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetAngle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserMessage {
    // message oneof groups
    pub content: ::std::option::Option<UserMessage_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserMessage {
    fn default() -> &'a UserMessage {
        <UserMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UserMessage_oneof_content {
    userAction(UserAction),
    joinGame(JoinGame),
    ping(Ping),
    targetAngle(TargetAngle),
}

impl UserMessage {
    pub fn new() -> UserMessage {
        ::std::default::Default::default()
    }

    // .superstellar.UserAction userAction = 1;


    pub fn get_userAction(&self) -> &UserAction {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::userAction(ref v)) => v,
            _ => <UserAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_userAction(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_userAction(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::userAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_userAction(&mut self, v: UserAction) {
        self.content = ::std::option::Option::Some(UserMessage_oneof_content::userAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_userAction(&mut self) -> &mut UserAction {
        if let ::std::option::Option::Some(UserMessage_oneof_content::userAction(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(UserMessage_oneof_content::userAction(UserAction::new()));
        }
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::userAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_userAction(&mut self) -> UserAction {
        if self.has_userAction() {
            match self.content.take() {
                ::std::option::Option::Some(UserMessage_oneof_content::userAction(v)) => v,
                _ => panic!(),
            }
        } else {
            UserAction::new()
        }
    }

    // .superstellar.JoinGame joinGame = 2;


    pub fn get_joinGame(&self) -> &JoinGame {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::joinGame(ref v)) => v,
            _ => <JoinGame as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_joinGame(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_joinGame(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::joinGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_joinGame(&mut self, v: JoinGame) {
        self.content = ::std::option::Option::Some(UserMessage_oneof_content::joinGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_joinGame(&mut self) -> &mut JoinGame {
        if let ::std::option::Option::Some(UserMessage_oneof_content::joinGame(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(UserMessage_oneof_content::joinGame(JoinGame::new()));
        }
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::joinGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_joinGame(&mut self) -> JoinGame {
        if self.has_joinGame() {
            match self.content.take() {
                ::std::option::Option::Some(UserMessage_oneof_content::joinGame(v)) => v,
                _ => panic!(),
            }
        } else {
            JoinGame::new()
        }
    }

    // .superstellar.Ping ping = 3;


    pub fn get_ping(&self) -> &Ping {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::ping(ref v)) => v,
            _ => <Ping as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ping(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: Ping) {
        self.content = ::std::option::Option::Some(UserMessage_oneof_content::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut Ping {
        if let ::std::option::Option::Some(UserMessage_oneof_content::ping(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(UserMessage_oneof_content::ping(Ping::new()));
        }
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> Ping {
        if self.has_ping() {
            match self.content.take() {
                ::std::option::Option::Some(UserMessage_oneof_content::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            Ping::new()
        }
    }

    // .superstellar.TargetAngle targetAngle = 4;


    pub fn get_targetAngle(&self) -> &TargetAngle {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(ref v)) => v,
            _ => <TargetAngle as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_targetAngle(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_targetAngle(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_targetAngle(&mut self, v: TargetAngle) {
        self.content = ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_targetAngle(&mut self) -> &mut TargetAngle {
        if let ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(TargetAngle::new()));
        }
        match self.content {
            ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_targetAngle(&mut self) -> TargetAngle {
        if self.has_targetAngle() {
            match self.content.take() {
                ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(v)) => v,
                _ => panic!(),
            }
        } else {
            TargetAngle::new()
        }
    }
}

impl ::protobuf::Message for UserMessage {
    fn is_initialized(&self) -> bool {
        if let Some(UserMessage_oneof_content::userAction(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserMessage_oneof_content::joinGame(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserMessage_oneof_content::ping(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UserMessage_oneof_content::targetAngle(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(UserMessage_oneof_content::userAction(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(UserMessage_oneof_content::joinGame(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(UserMessage_oneof_content::ping(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(UserMessage_oneof_content::targetAngle(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &UserMessage_oneof_content::userAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserMessage_oneof_content::joinGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserMessage_oneof_content::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UserMessage_oneof_content::targetAngle(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &UserMessage_oneof_content::userAction(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserMessage_oneof_content::joinGame(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserMessage_oneof_content::ping(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UserMessage_oneof_content::targetAngle(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserMessage {
        UserMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, UserAction>(
                "userAction",
                UserMessage::has_userAction,
                UserMessage::get_userAction,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JoinGame>(
                "joinGame",
                UserMessage::has_joinGame,
                UserMessage::get_joinGame,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ping>(
                "ping",
                UserMessage::has_ping,
                UserMessage::get_ping,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TargetAngle>(
                "targetAngle",
                UserMessage::has_targetAngle,
                UserMessage::get_targetAngle,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserMessage>(
                "UserMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserMessage {
        static instance: ::protobuf::rt::LazyV2<UserMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserMessage::new)
    }
}

impl ::protobuf::Clear for UserMessage {
    fn clear(&mut self) {
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rank {
    // message fields
    pub id: u32,
    pub score: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rank {
    fn default() -> &'a Rank {
        <Rank as ::protobuf::Message>::default_instance()
    }
}

impl Rank {
    pub fn new() -> Rank {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // uint32 score = 2;


    pub fn get_score(&self) -> u32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = v;
    }
}

impl ::protobuf::Message for Rank {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(2, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.score != 0 {
            os.write_uint32(2, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rank {
        Rank::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Rank| { &m.id },
                |m: &mut Rank| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &Rank| { &m.score },
                |m: &mut Rank| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rank>(
                "Rank",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rank {
        static instance: ::protobuf::rt::LazyV2<Rank> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rank::new)
    }
}

impl ::protobuf::Clear for Rank {
    fn clear(&mut self) {
        self.id = 0;
        self.score = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rank {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rank {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Leaderboard {
    // message fields
    pub ranks: ::protobuf::RepeatedField<Rank>,
    pub clientId: u32,
    pub userScore: u32,
    pub userPosition: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Leaderboard {
    fn default() -> &'a Leaderboard {
        <Leaderboard as ::protobuf::Message>::default_instance()
    }
}

impl Leaderboard {
    pub fn new() -> Leaderboard {
        ::std::default::Default::default()
    }

    // repeated .superstellar.Rank ranks = 1;


    pub fn get_ranks(&self) -> &[Rank] {
        &self.ranks
    }
    pub fn clear_ranks(&mut self) {
        self.ranks.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranks(&mut self, v: ::protobuf::RepeatedField<Rank>) {
        self.ranks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranks(&mut self) -> &mut ::protobuf::RepeatedField<Rank> {
        &mut self.ranks
    }

    // Take field
    pub fn take_ranks(&mut self) -> ::protobuf::RepeatedField<Rank> {
        ::std::mem::replace(&mut self.ranks, ::protobuf::RepeatedField::new())
    }

    // uint32 clientId = 2;


    pub fn get_clientId(&self) -> u32 {
        self.clientId
    }
    pub fn clear_clientId(&mut self) {
        self.clientId = 0;
    }

    // Param is passed by value, moved
    pub fn set_clientId(&mut self, v: u32) {
        self.clientId = v;
    }

    // uint32 userScore = 3;


    pub fn get_userScore(&self) -> u32 {
        self.userScore
    }
    pub fn clear_userScore(&mut self) {
        self.userScore = 0;
    }

    // Param is passed by value, moved
    pub fn set_userScore(&mut self, v: u32) {
        self.userScore = v;
    }

    // uint32 userPosition = 4;


    pub fn get_userPosition(&self) -> u32 {
        self.userPosition
    }
    pub fn clear_userPosition(&mut self) {
        self.userPosition = 0;
    }

    // Param is passed by value, moved
    pub fn set_userPosition(&mut self, v: u32) {
        self.userPosition = v;
    }
}

impl ::protobuf::Message for Leaderboard {
    fn is_initialized(&self) -> bool {
        for v in &self.ranks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranks)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clientId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.userScore = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.userPosition = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ranks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.clientId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.clientId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.userScore != 0 {
            my_size += ::protobuf::rt::value_size(3, self.userScore, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.userPosition != 0 {
            my_size += ::protobuf::rt::value_size(4, self.userPosition, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ranks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.clientId != 0 {
            os.write_uint32(2, self.clientId)?;
        }
        if self.userScore != 0 {
            os.write_uint32(3, self.userScore)?;
        }
        if self.userPosition != 0 {
            os.write_uint32(4, self.userPosition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Leaderboard {
        Leaderboard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rank>>(
                "ranks",
                |m: &Leaderboard| { &m.ranks },
                |m: &mut Leaderboard| { &mut m.ranks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "clientId",
                |m: &Leaderboard| { &m.clientId },
                |m: &mut Leaderboard| { &mut m.clientId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "userScore",
                |m: &Leaderboard| { &m.userScore },
                |m: &mut Leaderboard| { &mut m.userScore },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "userPosition",
                |m: &Leaderboard| { &m.userPosition },
                |m: &mut Leaderboard| { &mut m.userPosition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Leaderboard>(
                "Leaderboard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Leaderboard {
        static instance: ::protobuf::rt::LazyV2<Leaderboard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Leaderboard::new)
    }
}

impl ::protobuf::Clear for Leaderboard {
    fn clear(&mut self) {
        self.ranks.clear();
        self.clientId = 0;
        self.userScore = 0;
        self.userPosition = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Leaderboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Leaderboard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreBoardItem {
    // message fields
    pub score: u32,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScoreBoardItem {
    fn default() -> &'a ScoreBoardItem {
        <ScoreBoardItem as ::protobuf::Message>::default_instance()
    }
}

impl ScoreBoardItem {
    pub fn new() -> ScoreBoardItem {
        ::std::default::Default::default()
    }

    // uint32 score = 1;


    pub fn get_score(&self) -> u32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ScoreBoardItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(1, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.score != 0 {
            os.write_uint32(1, self.score)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScoreBoardItem {
        ScoreBoardItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &ScoreBoardItem| { &m.score },
                |m: &mut ScoreBoardItem| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ScoreBoardItem| { &m.name },
                |m: &mut ScoreBoardItem| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScoreBoardItem>(
                "ScoreBoardItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScoreBoardItem {
        static instance: ::protobuf::rt::LazyV2<ScoreBoardItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScoreBoardItem::new)
    }
}

impl ::protobuf::Clear for ScoreBoardItem {
    fn clear(&mut self) {
        self.score = 0;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreBoardItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreBoardItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreBoard {
    // message fields
    pub items: ::protobuf::RepeatedField<ScoreBoardItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScoreBoard {
    fn default() -> &'a ScoreBoard {
        <ScoreBoard as ::protobuf::Message>::default_instance()
    }
}

impl ScoreBoard {
    pub fn new() -> ScoreBoard {
        ::std::default::Default::default()
    }

    // repeated .superstellar.ScoreBoardItem items = 1;


    pub fn get_items(&self) -> &[ScoreBoardItem] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ScoreBoardItem>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ScoreBoardItem> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ScoreBoardItem> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScoreBoard {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScoreBoard {
        ScoreBoard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreBoardItem>>(
                "items",
                |m: &ScoreBoard| { &m.items },
                |m: &mut ScoreBoard| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScoreBoard>(
                "ScoreBoard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScoreBoard {
        static instance: ::protobuf::rt::LazyV2<ScoreBoard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScoreBoard::new)
    }
}

impl ::protobuf::Clear for ScoreBoard {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreBoard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreBoard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Direction {
    DIR_CENTER = 0,
    DIR_RIGHT = 1,
    DIR_LEFT = 2,
}

impl ::protobuf::ProtobufEnum for Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::DIR_CENTER),
            1 => ::std::option::Option::Some(Direction::DIR_RIGHT),
            2 => ::std::option::Option::Some(Direction::DIR_LEFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Direction] = &[
            Direction::DIR_CENTER,
            Direction::DIR_RIGHT,
            Direction::DIR_LEFT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Direction>("Direction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Direction {
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::DIR_CENTER
    }
}

impl ::protobuf::reflect::ProtobufValue for Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserInput {
    CENTER = 0,
    LEFT = 1,
    RIGHT = 2,
    THRUST_ON = 3,
    THRUST_OFF = 4,
    STRAIGHT_FIRE_START = 5,
    TURRET_FIRE_START = 6,
    FIRE_STOP = 7,
    BOOST_ON = 8,
    BOOST_OFF = 9,
}

impl ::protobuf::ProtobufEnum for UserInput {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserInput> {
        match value {
            0 => ::std::option::Option::Some(UserInput::CENTER),
            1 => ::std::option::Option::Some(UserInput::LEFT),
            2 => ::std::option::Option::Some(UserInput::RIGHT),
            3 => ::std::option::Option::Some(UserInput::THRUST_ON),
            4 => ::std::option::Option::Some(UserInput::THRUST_OFF),
            5 => ::std::option::Option::Some(UserInput::STRAIGHT_FIRE_START),
            6 => ::std::option::Option::Some(UserInput::TURRET_FIRE_START),
            7 => ::std::option::Option::Some(UserInput::FIRE_STOP),
            8 => ::std::option::Option::Some(UserInput::BOOST_ON),
            9 => ::std::option::Option::Some(UserInput::BOOST_OFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserInput] = &[
            UserInput::CENTER,
            UserInput::LEFT,
            UserInput::RIGHT,
            UserInput::THRUST_ON,
            UserInput::THRUST_OFF,
            UserInput::STRAIGHT_FIRE_START,
            UserInput::TURRET_FIRE_START,
            UserInput::FIRE_STOP,
            UserInput::BOOST_ON,
            UserInput::BOOST_OFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UserInput>("UserInput", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UserInput {
}

impl ::std::default::Default for UserInput {
    fn default() -> Self {
        UserInput::CENTER
    }
}

impl ::protobuf::reflect::ProtobufValue for UserInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bprotobuf/superstellar.proto\x12\x0csuperstellar\"\xd5\x05\n\x07Mes\
    sage\x12+\n\x05space\x18\x01\x20\x01(\x0b2\x13.superstellar.SpaceH\0R\
    \x05space\x12+\n\x05hello\x18\x02\x20\x01(\x0b2\x13.superstellar.HelloH\
    \0R\x05hello\x12:\n\nplayerLeft\x18\x03\x20\x01(\x0b2\x18.superstellar.P\
    layerLeftH\0R\nplayerLeft\x12I\n\x0fprojectileFired\x18\x04\x20\x01(\x0b\
    2\x1d.superstellar.ProjectileFiredH\0R\x0fprojectileFired\x12C\n\rprojec\
    tileHit\x18\x05\x20\x01(\x0b2\x1b.superstellar.ProjectileHitH\0R\rprojec\
    tileHit\x12@\n\x0cplayerJoined\x18\x06\x20\x01(\x0b2\x1a.superstellar.Pl\
    ayerJoinedH\0R\x0cplayerJoined\x12=\n\x0bjoinGameAck\x18\x07\x20\x01(\
    \x0b2\x19.superstellar.JoinGameAckH\0R\x0bjoinGameAck\x12=\n\x0bleaderbo\
    ard\x18\x08\x20\x01(\x0b2\x19.superstellar.LeaderboardH\0R\x0bleaderboar\
    d\x12:\n\nplayerDied\x18\t\x20\x01(\x0b2\x18.superstellar.PlayerDiedH\0R\
    \nplayerDied\x12(\n\x04pong\x18\n\x20\x01(\x0b2\x12.superstellar.PongH\0\
    R\x04pong\x12:\n\nscoreBoard\x18\x0b\x20\x01(\x0b2\x18.superstellar.Scor\
    eBoardH\0R\nscoreBoard\x127\n\tconstants\x18\x0c\x20\x01(\x0b2\x17.super\
    stellar.ConstantsH\0R\tconstantsB\t\n\x07content\"#\n\x05Point\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x11R\
    \x01y\"$\n\x06Vector\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x01(\x02R\x01y\"\xc9\x03\n\tSpaceship\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12/\n\x08position\x18\x02\x20\x01(\x0b2\x13.\
    superstellar.PointR\x08position\x120\n\x08velocity\x18\x03\x20\x01(\x0b2\
    \x14.superstellar.VectorR\x08velocity\x12\x16\n\x06facing\x18\x04\x20\
    \x01(\x01R\x06facing\x12(\n\x0fangularVelocity\x18\x05\x20\x01(\x01R\x0f\
    angularVelocity\x12?\n\x0einputDirection\x18\x06\x20\x01(\x0e2\x17.super\
    stellar.DirectionR\x0einputDirection\x12\x20\n\x0binputThrust\x18\x07\
    \x20\x01(\x08R\x0binputThrust\x12\x1e\n\ninputBoost\x18\x08\x20\x01(\x08\
    R\ninputBoost\x12\x14\n\x05maxHp\x18\t\x20\x01(\rR\x05maxHp\x12\x0e\n\
    \x02hp\x18\n\x20\x01(\rR\x02hp\x12\x1c\n\tmaxEnergy\x18\x0b\x20\x01(\rR\
    \tmaxEnergy\x12\x16\n\x06energy\x18\x0c\x20\x01(\rR\x06energy\x12(\n\x0f\
    autoRepairDelay\x18\r\x20\x01(\rR\x0fautoRepairDelay\"\xbf\x01\n\x08Aste\
    roid\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12/\n\x08position\x18\
    \x02\x20\x01(\x0b2\x13.superstellar.PointR\x08position\x120\n\x08velocit\
    y\x18\x03\x20\x01(\x0b2\x14.superstellar.VectorR\x08velocity\x12\x16\n\
    \x06facing\x18\x04\x20\x01(\x01R\x06facing\x12(\n\x0fangularVelocity\x18\
    \x05\x20\x01(\x01R\x0fangularVelocity\"\xc4\x01\n\x0fProjectileFired\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x18\n\x07frameId\x18\x02\x20\
    \x01(\rR\x07frameId\x12+\n\x06origin\x18\x03\x20\x01(\x0b2\x13.superstel\
    lar.PointR\x06origin\x120\n\x08velocity\x18\x04\x20\x01(\x0b2\x14.supers\
    tellar.VectorR\x08velocity\x12\x16\n\x06facing\x18\x05\x20\x01(\x02R\x06\
    facing\x12\x10\n\x03ttl\x18\x06\x20\x01(\rR\x03ttl\"\x1f\n\rProjectileHi\
    t\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\"\x1c\n\nPlayerLeft\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\rR\x02id\":\n\x0cPlayerJoined\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08\
    username\"8\n\nPlayerDied\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x1a\n\x08killedBy\x18\x02\x20\x01(\rR\x08killedBy\"\x16\n\x04Ping\x12\
    \x0e\n\x02Id\x18\x01\x20\x01(\rR\x02Id\"\x16\n\x04Pong\x12\x0e\n\x02Id\
    \x18\x01\x20\x01(\rR\x02Id\"\x9e\x01\n\x05Space\x12&\n\x0ephysicsFrameID\
    \x18\x01\x20\x01(\rR\x0ephysicsFrameID\x127\n\nspaceships\x18\x02\x20\
    \x03(\x0b2\x17.superstellar.SpaceshipR\nspaceships\x124\n\tasteroids\x18\
    \x03\x20\x03(\x0b2\x16.superstellar.AsteroidR\tasteroids\"\xa7\x01\n\x05\
    Hello\x12\x12\n\x04myId\x18\x01\x20\x01(\rR\x04myId\x12I\n\x0cidToUserna\
    me\x18\x02\x20\x03(\x0b2%.superstellar.Hello.IdToUsernameEntryR\x0cidToU\
    sername\x1a?\n\x11IdToUsernameEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xa1\
    \x06\n\tConstants\x12\x20\n\x0bworldRadius\x18\x01\x20\x01(\x02R\x0bworl\
    dRadius\x122\n\x14boundaryAnnulusWidth\x18\x02\x20\x01(\x02R\x14boundary\
    AnnulusWidth\x124\n\x15spaceshipAcceleration\x18\x03\x20\x01(\x02R\x15sp\
    aceshipAcceleration\x120\n\x13frictionCoefficient\x18\x04\x20\x01(\x02R\
    \x13frictionCoefficient\x12T\n%spaceshipNonlinearAngularAcceleration\x18\
    \x05\x20\x01(\x02R%spaceshipNonlinearAngularAcceleration\x12N\n\"spacesh\
    ipLinearAngularAcceleration\x18\x06\x20\x01(\x02R\"spaceshipLinearAngula\
    rAcceleration\x12@\n\x1bspaceshipMaxAngularVelocity\x18\x07\x20\x01(\x02\
    R\x1bspaceshipMaxAngularVelocity\x12:\n\x18spaceshipAngularFriction\x18\
    \x08\x20\x01(\x02R\x18spaceshipAngularFriction\x12,\n\x11spaceshipMaxSpe\
    ed\x18\t\x20\x01(\rR\x11spaceshipMaxSpeed\x122\n\x14spaceshipBoostFactor\
    \x18\n\x20\x01(\x02R\x14spaceshipBoostFactor\x12.\n\x12autoRepairInterva\
    l\x18\x0b\x20\x01(\rR\x12autoRepairInterval\x12*\n\x10autoRepairAmount\
    \x18\x0c\x20\x01(\rR\x10autoRepairAmount\x12:\n\x18autoEnergyRechargeAmo\
    unt\x18\r\x20\x01(\rR\x18autoEnergyRechargeAmount\x128\n\x17boostPerFram\
    eEnergyCost\x18\x0e\x20\x01(\rR\x17boostPerFrameEnergyCost\"&\n\x08JoinG\
    ame\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\"=\n\x0bJoinGa\
    meAck\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x14\n\
    \x05error\x18\x02\x20\x01(\tR\x05error\"C\n\nUserAction\x125\n\tuserInpu\
    t\x18\x01\x20\x01(\x0e2\x17.superstellar.UserInputR\tuserInput\"#\n\x0bT\
    argetAngle\x12\x14\n\x05angle\x18\x01\x20\x01(\x02R\x05angle\"\xf3\x01\n\
    \x0bUserMessage\x12:\n\nuserAction\x18\x01\x20\x01(\x0b2\x18.superstella\
    r.UserActionH\0R\nuserAction\x124\n\x08joinGame\x18\x02\x20\x01(\x0b2\
    \x16.superstellar.JoinGameH\0R\x08joinGame\x12(\n\x04ping\x18\x03\x20\
    \x01(\x0b2\x12.superstellar.PingH\0R\x04ping\x12=\n\x0btargetAngle\x18\
    \x04\x20\x01(\x0b2\x19.superstellar.TargetAngleH\0R\x0btargetAngleB\t\n\
    \x07content\",\n\x04Rank\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x14\n\x05score\x18\x02\x20\x01(\rR\x05score\"\x95\x01\n\x0bLeaderboard\
    \x12(\n\x05ranks\x18\x01\x20\x03(\x0b2\x12.superstellar.RankR\x05ranks\
    \x12\x1a\n\x08clientId\x18\x02\x20\x01(\rR\x08clientId\x12\x1c\n\tuserSc\
    ore\x18\x03\x20\x01(\rR\tuserScore\x12\"\n\x0cuserPosition\x18\x04\x20\
    \x01(\rR\x0cuserPosition\":\n\x0eScoreBoardItem\x12\x14\n\x05score\x18\
    \x01\x20\x01(\rR\x05score\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \"@\n\nScoreBoard\x122\n\x05items\x18\x01\x20\x03(\x0b2\x1c.superstellar\
    .ScoreBoardItemR\x05items*8\n\tDirection\x12\x0e\n\nDIR_CENTER\x10\0\x12\
    \r\n\tDIR_RIGHT\x10\x01\x12\x0c\n\x08DIR_LEFT\x10\x02*\xa7\x01\n\tUserIn\
    put\x12\n\n\x06CENTER\x10\0\x12\x08\n\x04LEFT\x10\x01\x12\t\n\x05RIGHT\
    \x10\x02\x12\r\n\tTHRUST_ON\x10\x03\x12\x0e\n\nTHRUST_OFF\x10\x04\x12\
    \x17\n\x13STRAIGHT_FIRE_START\x10\x05\x12\x15\n\x11TURRET_FIRE_START\x10\
    \x06\x12\r\n\tFIRE_STOP\x10\x07\x12\x0c\n\x08BOOST_ON\x10\x08\x12\r\n\tB\
    OOST_OFF\x10\tB\x06Z\x04.;pbJ\xec/\n\x07\x12\x05\0\0\xb6\x01\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x15\n\x08\n\x01\
    \x08\x12\x03\x02\0\x1b\n\t\n\x02\x08\x0b\x12\x03\x02\0\x1b\n\n\n\x02\x04\
    \0\x12\x04\x04\0\x13\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x0f\n\x0c\n\
    \x04\x04\0\x08\0\x12\x04\x05\x02\x12\x03\n\x0c\n\x05\x04\0\x08\0\x01\x12\
    \x03\x05\x08\x0f\n\x0b\n\x04\x04\0\x02\0\x12\x03\x06\x04*\n\x0c\n\x05\
    \x04\0\x02\0\x06\x12\x03\x06\x04\t\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x06\x14\x19\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x06()\n\x0b\n\x04\x04\0\
    \x02\x01\x12\x03\x07\x04*\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x07\x04\
    \t\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x07\x14\x19\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03\x07()\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x08\x04*\n\
    \x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x08\x04\x0e\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x08\x14\x1e\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x08()\
    \n\x0b\n\x04\x04\0\x02\x03\x12\x03\t\x04*\n\x0c\n\x05\x04\0\x02\x03\x06\
    \x12\x03\t\x04\x13\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\t\x14#\n\x0c\n\
    \x05\x04\0\x02\x03\x03\x12\x03\t()\n\x0b\n\x04\x04\0\x02\x04\x12\x03\n\
    \x04*\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\n\x04\x11\n\x0c\n\x05\x04\0\
    \x02\x04\x01\x12\x03\n\x14!\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\n()\n\
    \x0b\n\x04\x04\0\x02\x05\x12\x03\x0b\x04*\n\x0c\n\x05\x04\0\x02\x05\x06\
    \x12\x03\x0b\x04\x10\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x0b\x14\x20\n\
    \x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x0b()\n\x0b\n\x04\x04\0\x02\x06\x12\
    \x03\x0c\x04*\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03\x0c\x04\x0f\n\x0c\n\
    \x05\x04\0\x02\x06\x01\x12\x03\x0c\x14\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\
    \x12\x03\x0c()\n\x0b\n\x04\x04\0\x02\x07\x12\x03\r\x04*\n\x0c\n\x05\x04\
    \0\x02\x07\x06\x12\x03\r\x04\x0f\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\r\
    \x14\x1f\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\r()\n\x0b\n\x04\x04\0\x02\
    \x08\x12\x03\x0e\x04*\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03\x0e\x04\x0e\
    \n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03\x0e\x14\x1e\n\x0c\n\x05\x04\0\x02\
    \x08\x03\x12\x03\x0e()\n\x0b\n\x04\x04\0\x02\t\x12\x03\x0f\x04+\n\x0c\n\
    \x05\x04\0\x02\t\x06\x12\x03\x0f\x04\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\
    \x03\x0f\x14\x18\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03\x0f(*\n\x0b\n\x04\
    \x04\0\x02\n\x12\x03\x10\x04+\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03\x10\
    \x04\x0e\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03\x10\x14\x1e\n\x0c\n\x05\x04\
    \0\x02\n\x03\x12\x03\x10(*\n\x0b\n\x04\x04\0\x02\x0b\x12\x03\x11\x04+\n\
    \x0c\n\x05\x04\0\x02\x0b\x06\x12\x03\x11\x04\r\n\x0c\n\x05\x04\0\x02\x0b\
    \x01\x12\x03\x11\x14\x1d\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03\x11(*\n\n\
    \n\x02\x04\x01\x12\x04\x15\0\x18\x01\n\n\n\x03\x04\x01\x01\x12\x03\x15\
    \x08\r\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x16\x02\x0f\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x16\
    \t\n\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x16\r\x0e\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03\x17\x02\x0f\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x17\
    \x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x17\t\n\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03\x17\r\x0e\n\n\n\x02\x04\x02\x12\x04\x1a\0\x1d\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03\x1a\x08\x0e\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03\x1b\x02\x0e\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1b\x02\x07\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1b\x08\t\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03\x1b\x0c\r\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x1c\x02\x0e\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x1c\x02\x07\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x1c\x08\t\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x1c\x0c\r\n\n\n\x02\x05\0\x12\x04\x1f\0#\x01\n\n\n\x03\x05\0\x01\x12\
    \x03\x1f\x05\x0e\n\x0b\n\x04\x05\0\x02\0\x12\x03\x20\x02\x11\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\x20\x02\x0c\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\
    \x20\x0f\x10\n\x0b\n\x04\x05\0\x02\x01\x12\x03!\x02\x10\n\x0c\n\x05\x05\
    \0\x02\x01\x01\x12\x03!\x02\x0b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03!\
    \x0e\x0f\n\x0b\n\x04\x05\0\x02\x02\x12\x03\"\x02\x0f\n\x0c\n\x05\x05\0\
    \x02\x02\x01\x12\x03\"\x02\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\"\r\
    \x0e\n\n\n\x02\x04\x03\x12\x04%\03\x01\n\n\n\x03\x04\x03\x01\x12\x03%\
    \x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x03&\x02\x13\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03&\x0c\
    \x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03&\x11\x12\n\x0b\n\x04\x04\x03\
    \x02\x01\x12\x03'\x02\x19\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03'\x02\
    \x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03'\x0c\x14\n\x0c\n\x05\x04\
    \x03\x02\x01\x03\x12\x03'\x17\x18\n\x0b\n\x04\x04\x03\x02\x02\x12\x03(\
    \x02\x19\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03(\x02\x08\n\x0c\n\x05\
    \x04\x03\x02\x02\x01\x12\x03(\x0c\x14\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03(\x17\x18\n\x0b\n\x04\x04\x03\x02\x03\x12\x03)\x02\x17\n\x0c\n\
    \x05\x04\x03\x02\x03\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\
    \x01\x12\x03)\x0c\x12\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03)\x15\x16\n\
    \x0b\n\x04\x04\x03\x02\x04\x12\x03*\x02\x20\n\x0c\n\x05\x04\x03\x02\x04\
    \x05\x12\x03*\x02\x08\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03*\x0c\x1b\n\
    \x0c\n\x05\x04\x03\x02\x04\x03\x12\x03*\x1e\x1f\n\x0b\n\x04\x04\x03\x02\
    \x05\x12\x03+\x02\x1f\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03+\x02\x0b\n\
    \x0c\n\x05\x04\x03\x02\x05\x01\x12\x03+\x0c\x1a\n\x0c\n\x05\x04\x03\x02\
    \x05\x03\x12\x03+\x1d\x1e\n\x0b\n\x04\x04\x03\x02\x06\x12\x03,\x02\x1c\n\
    \x0c\n\x05\x04\x03\x02\x06\x05\x12\x03,\x02\x06\n\x0c\n\x05\x04\x03\x02\
    \x06\x01\x12\x03,\x0c\x17\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03,\x1a\
    \x1b\n\x0b\n\x04\x04\x03\x02\x07\x12\x03-\x02\x1b\n\x0c\n\x05\x04\x03\
    \x02\x07\x05\x12\x03-\x02\x06\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03-\
    \x0c\x16\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03-\x19\x1a\n\x0b\n\x04\
    \x04\x03\x02\x08\x12\x03.\x02\x16\n\x0c\n\x05\x04\x03\x02\x08\x05\x12\
    \x03.\x02\x08\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x03.\x0c\x11\n\x0c\n\
    \x05\x04\x03\x02\x08\x03\x12\x03.\x14\x15\n\x0b\n\x04\x04\x03\x02\t\x12\
    \x03/\x02\x14\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03/\x02\x08\n\x0c\n\x05\
    \x04\x03\x02\t\x01\x12\x03/\x0c\x0e\n\x0c\n\x05\x04\x03\x02\t\x03\x12\
    \x03/\x11\x13\n\x0b\n\x04\x04\x03\x02\n\x12\x030\x02\x1b\n\x0c\n\x05\x04\
    \x03\x02\n\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x030\
    \x0c\x15\n\x0c\n\x05\x04\x03\x02\n\x03\x12\x030\x18\x1a\n\x0b\n\x04\x04\
    \x03\x02\x0b\x12\x031\x02\x18\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x031\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\x0b\x01\x12\x031\x0c\x12\n\x0c\n\x05\
    \x04\x03\x02\x0b\x03\x12\x031\x15\x17\n\x0b\n\x04\x04\x03\x02\x0c\x12\
    \x032\x02!\n\x0c\n\x05\x04\x03\x02\x0c\x05\x12\x032\x02\x08\n\x0c\n\x05\
    \x04\x03\x02\x0c\x01\x12\x032\x0c\x1b\n\x0c\n\x05\x04\x03\x02\x0c\x03\
    \x12\x032\x1e\x20\n\n\n\x02\x04\x04\x12\x045\0;\x01\n\n\n\x03\x04\x04\
    \x01\x12\x035\x08\x10\n\x0b\n\x04\x04\x04\x02\0\x12\x036\x02\x13\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x036\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x036\x0c\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x036\x11\x12\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x037\x02\x19\n\x0c\n\x05\x04\x04\x02\x01\x06\
    \x12\x037\x02\x07\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x037\x0c\x14\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x037\x17\x18\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x038\x02\x19\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x038\x02\x08\n\x0c\
    \n\x05\x04\x04\x02\x02\x01\x12\x038\x0c\x14\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x038\x17\x18\n\x0b\n\x04\x04\x04\x02\x03\x12\x039\x02\x17\n\x0c\
    \n\x05\x04\x04\x02\x03\x05\x12\x039\x02\x08\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x039\x0c\x12\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x039\x15\x16\n\
    \x0b\n\x04\x04\x04\x02\x04\x12\x03:\x02\x20\n\x0c\n\x05\x04\x04\x02\x04\
    \x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03:\x0c\x1b\n\
    \x0c\n\x05\x04\x04\x02\x04\x03\x12\x03:\x1e\x1f\n\n\n\x02\x04\x05\x12\
    \x04=\0D\x01\n\n\n\x03\x04\x05\x01\x12\x03=\x08\x17\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03>\x02\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03>\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03>\x0c\x0e\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03>\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x03?\x02\x18\n\x0c\
    \n\x05\x04\x05\x02\x01\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03?\x0c\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03?\x16\x17\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03@\x02\x17\n\x0c\n\x05\x04\x05\x02\x02\
    \x06\x12\x03@\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03@\x0c\x12\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03@\x15\x16\n\x0b\n\x04\x04\x05\x02\
    \x03\x12\x03A\x02\x19\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\x03A\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03A\x0c\x14\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03A\x17\x18\n\x0b\n\x04\x04\x05\x02\x04\x12\x03B\x02\x17\n\
    \x0c\n\x05\x04\x05\x02\x04\x05\x12\x03B\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03B\x0c\x12\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03B\x15\
    \x16\n\x0b\n\x04\x04\x05\x02\x05\x12\x03C\x02\x14\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03C\
    \x0c\x0f\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03C\x12\x13\n\n\n\x02\x04\
    \x06\x12\x04F\0H\x01\n\n\n\x03\x04\x06\x01\x12\x03F\x08\x15\n\x0b\n\x04\
    \x04\x06\x02\0\x12\x03G\x02\x13\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03G\
    \x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03G\x0c\x0e\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x03G\x11\x12\n\n\n\x02\x04\x07\x12\x04J\0L\x01\n\n\n\
    \x03\x04\x07\x01\x12\x03J\x08\x12\n\x0b\n\x04\x04\x07\x02\0\x12\x03K\x02\
    \x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\x07\
    \x02\0\x01\x12\x03K\t\x0b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03K\x0e\x0f\
    \n\n\n\x02\x04\x08\x12\x04N\0Q\x01\n\n\n\x03\x04\x08\x01\x12\x03N\x08\
    \x14\n\x0b\n\x04\x04\x08\x02\0\x12\x03O\x02\x10\n\x0c\n\x05\x04\x08\x02\
    \0\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03O\t\x0b\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03O\x0e\x0f\n\x0b\n\x04\x04\x08\x02\
    \x01\x12\x03P\x02\x16\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03P\x02\x08\n\
    \x0c\n\x05\x04\x08\x02\x01\x01\x12\x03P\t\x11\n\x0c\n\x05\x04\x08\x02\
    \x01\x03\x12\x03P\x14\x15\n\n\n\x02\x04\t\x12\x04S\0V\x01\n\n\n\x03\x04\
    \t\x01\x12\x03S\x08\x12\n\x0b\n\x04\x04\t\x02\0\x12\x03T\x02\x10\n\x0c\n\
    \x05\x04\t\x02\0\x05\x12\x03T\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\
    \x03T\t\x0b\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03T\x0e\x0f\n\x0b\n\x04\x04\
    \t\x02\x01\x12\x03U\x02\x16\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03U\x02\
    \x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03U\t\x11\n\x0c\n\x05\x04\t\x02\
    \x01\x03\x12\x03U\x14\x15\n\n\n\x02\x04\n\x12\x04X\0Z\x01\n\n\n\x03\x04\
    \n\x01\x12\x03X\x08\x0c\n\x0b\n\x04\x04\n\x02\0\x12\x03Y\x02\x10\n\x0c\n\
    \x05\x04\n\x02\0\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\n\x02\0\x01\x12\
    \x03Y\t\x0b\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03Y\x0e\x0f\n\n\n\x02\x04\
    \x0b\x12\x04\\\0^\x01\n\n\n\x03\x04\x0b\x01\x12\x03\\\x08\x0c\n\x0b\n\
    \x04\x04\x0b\x02\0\x12\x03]\x02\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\
    \x03]\x02\x08\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03]\t\x0b\n\x0c\n\x05\
    \x04\x0b\x02\0\x03\x12\x03]\x0e\x0f\n\n\n\x02\x04\x0c\x12\x04`\0d\x01\n\
    \n\n\x03\x04\x0c\x01\x12\x03`\x08\r\n\x0b\n\x04\x04\x0c\x02\0\x12\x03a\
    \x02\x1c\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\
    \x0c\x02\0\x01\x12\x03a\t\x17\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03a\x1a\
    \x1b\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03b\x02$\n\x0c\n\x05\x04\x0c\x02\
    \x01\x04\x12\x03b\x02\n\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03b\x0b\x14\
    \n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03b\x15\x1f\n\x0c\n\x05\x04\x0c\
    \x02\x01\x03\x12\x03b\"#\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03c\x02\"\n\
    \x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03c\x02\n\n\x0c\n\x05\x04\x0c\x02\
    \x02\x06\x12\x03c\x0b\x13\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03c\x14\
    \x1d\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03c\x20!\n\n\n\x02\x04\r\x12\
    \x04f\0i\x01\n\n\n\x03\x04\r\x01\x12\x03f\x08\r\n\x0b\n\x04\x04\r\x02\0\
    \x12\x03g\x02\x12\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03g\x02\x08\n\x0c\n\
    \x05\x04\r\x02\0\x01\x12\x03g\t\r\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03g\
    \x10\x11\n\x0b\n\x04\x04\r\x02\x01\x12\x03h\x02'\n\x0c\n\x05\x04\r\x02\
    \x01\x06\x12\x03h\x02\x15\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03h\x16\"\n\
    \x0c\n\x05\x04\r\x02\x01\x03\x12\x03h%&\n\n\n\x02\x04\x0e\x12\x04k\0z\
    \x01\n\n\n\x03\x04\x0e\x01\x12\x03k\x08\x11\n\x0b\n\x04\x04\x0e\x02\0\
    \x12\x03l\x02\x18\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03l\x02\x07\n\x0c\n\
    \x05\x04\x0e\x02\0\x01\x12\x03l\x08\x13\n\x0c\n\x05\x04\x0e\x02\0\x03\
    \x12\x03l\x16\x17\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03m\x02\"\n\x0c\n\x05\
    \x04\x0e\x02\x01\x05\x12\x03m\x02\x07\n\x0c\n\x05\x04\x0e\x02\x01\x01\
    \x12\x03m\x08\x1c\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03m\x20!\n\x0b\n\
    \x04\x04\x0e\x02\x02\x12\x03n\x02\"\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\
    \x03n\x02\x07\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03n\x08\x1d\n\x0c\n\
    \x05\x04\x0e\x02\x02\x03\x12\x03n\x20!\n\x0b\n\x04\x04\x0e\x02\x03\x12\
    \x03o\x02\x20\n\x0c\n\x05\x04\x0e\x02\x03\x05\x12\x03o\x02\x07\n\x0c\n\
    \x05\x04\x0e\x02\x03\x01\x12\x03o\x08\x1b\n\x0c\n\x05\x04\x0e\x02\x03\
    \x03\x12\x03o\x1e\x1f\n\x0b\n\x04\x04\x0e\x02\x04\x12\x03p\x022\n\x0c\n\
    \x05\x04\x0e\x02\x04\x05\x12\x03p\x02\x07\n\x0c\n\x05\x04\x0e\x02\x04\
    \x01\x12\x03p\x08-\n\x0c\n\x05\x04\x0e\x02\x04\x03\x12\x03p01\n\x0b\n\
    \x04\x04\x0e\x02\x05\x12\x03q\x02/\n\x0c\n\x05\x04\x0e\x02\x05\x05\x12\
    \x03q\x02\x07\n\x0c\n\x05\x04\x0e\x02\x05\x01\x12\x03q\x08*\n\x0c\n\x05\
    \x04\x0e\x02\x05\x03\x12\x03q-.\n\x0b\n\x04\x04\x0e\x02\x06\x12\x03r\x02\
    (\n\x0c\n\x05\x04\x0e\x02\x06\x05\x12\x03r\x02\x07\n\x0c\n\x05\x04\x0e\
    \x02\x06\x01\x12\x03r\x08#\n\x0c\n\x05\x04\x0e\x02\x06\x03\x12\x03r&'\n\
    \x0b\n\x04\x04\x0e\x02\x07\x12\x03s\x02%\n\x0c\n\x05\x04\x0e\x02\x07\x05\
    \x12\x03s\x02\x07\n\x0c\n\x05\x04\x0e\x02\x07\x01\x12\x03s\x08\x20\n\x0c\
    \n\x05\x04\x0e\x02\x07\x03\x12\x03s#$\n\x0b\n\x04\x04\x0e\x02\x08\x12\
    \x03t\x02\x1f\n\x0c\n\x05\x04\x0e\x02\x08\x05\x12\x03t\x02\x08\n\x0c\n\
    \x05\x04\x0e\x02\x08\x01\x12\x03t\t\x1a\n\x0c\n\x05\x04\x0e\x02\x08\x03\
    \x12\x03t\x1d\x1e\n\x0b\n\x04\x04\x0e\x02\t\x12\x03u\x02\"\n\x0c\n\x05\
    \x04\x0e\x02\t\x05\x12\x03u\x02\x07\n\x0c\n\x05\x04\x0e\x02\t\x01\x12\
    \x03u\x08\x1c\n\x0c\n\x05\x04\x0e\x02\t\x03\x12\x03u\x1f!\n\x0b\n\x04\
    \x04\x0e\x02\n\x12\x03v\x02!\n\x0c\n\x05\x04\x0e\x02\n\x05\x12\x03v\x02\
    \x08\n\x0c\n\x05\x04\x0e\x02\n\x01\x12\x03v\t\x1b\n\x0c\n\x05\x04\x0e\
    \x02\n\x03\x12\x03v\x1e\x20\n\x0b\n\x04\x04\x0e\x02\x0b\x12\x03w\x02\x1f\
    \n\x0c\n\x05\x04\x0e\x02\x0b\x05\x12\x03w\x02\x08\n\x0c\n\x05\x04\x0e\
    \x02\x0b\x01\x12\x03w\t\x19\n\x0c\n\x05\x04\x0e\x02\x0b\x03\x12\x03w\x1c\
    \x1e\n\x0b\n\x04\x04\x0e\x02\x0c\x12\x03x\x02'\n\x0c\n\x05\x04\x0e\x02\
    \x0c\x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\x0e\x02\x0c\x01\x12\x03x\t!\n\
    \x0c\n\x05\x04\x0e\x02\x0c\x03\x12\x03x$&\n\x0b\n\x04\x04\x0e\x02\r\x12\
    \x03y\x02&\n\x0c\n\x05\x04\x0e\x02\r\x05\x12\x03y\x02\x08\n\x0c\n\x05\
    \x04\x0e\x02\r\x01\x12\x03y\t\x20\n\x0c\n\x05\x04\x0e\x02\r\x03\x12\x03y\
    #%\n\n\n\x02\x04\x0f\x12\x04|\0~\x01\n\n\n\x03\x04\x0f\x01\x12\x03|\x08\
    \x10\n\x0b\n\x04\x04\x0f\x02\0\x12\x03}\x02\x16\n\x0c\n\x05\x04\x0f\x02\
    \0\x05\x12\x03}\x02\x08\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03}\t\x11\n\
    \x0c\n\x05\x04\x0f\x02\0\x03\x12\x03}\x14\x15\n\x0c\n\x02\x04\x10\x12\
    \x06\x80\x01\0\x83\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x80\x01\x08\
    \x13\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x81\x01\x02\x15\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\x81\x01\x02\x06\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \x81\x01\t\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x81\x01\x13\x14\n\x0c\
    \n\x04\x04\x10\x02\x01\x12\x04\x82\x01\x02\x15\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x82\
    \x01\t\x0e\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x82\x01\x13\x14\n\x0c\n\
    \x02\x05\x01\x12\x06\x85\x01\0\x90\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\
    \x04\x85\x01\x05\x0e\n\x0c\n\x04\x05\x01\x02\0\x12\x04\x86\x01\x02\r\n\r\
    \n\x05\x05\x01\x02\0\x01\x12\x04\x86\x01\x02\x08\n\r\n\x05\x05\x01\x02\0\
    \x02\x12\x04\x86\x01\x0b\x0c\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\x87\x01\
    \x02\x0b\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\x87\x01\x02\x06\n\r\n\x05\
    \x05\x01\x02\x01\x02\x12\x04\x87\x01\t\n\n\x0c\n\x04\x05\x01\x02\x02\x12\
    \x04\x88\x01\x02\x0c\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\x88\x01\x02\
    \x07\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\x88\x01\n\x0b\n\x0c\n\x04\x05\
    \x01\x02\x03\x12\x04\x89\x01\x02\x10\n\r\n\x05\x05\x01\x02\x03\x01\x12\
    \x04\x89\x01\x02\x0b\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\x89\x01\x0e\
    \x0f\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\x8a\x01\x02\x11\n\r\n\x05\x05\
    \x01\x02\x04\x01\x12\x04\x8a\x01\x02\x0c\n\r\n\x05\x05\x01\x02\x04\x02\
    \x12\x04\x8a\x01\x0f\x10\n\x0c\n\x04\x05\x01\x02\x05\x12\x04\x8b\x01\x02\
    \x1a\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\x8b\x01\x02\x15\n\r\n\x05\x05\
    \x01\x02\x05\x02\x12\x04\x8b\x01\x18\x19\n\x0c\n\x04\x05\x01\x02\x06\x12\
    \x04\x8c\x01\x02\x18\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\x8c\x01\x02\
    \x13\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\x8c\x01\x16\x17\n\x0c\n\x04\
    \x05\x01\x02\x07\x12\x04\x8d\x01\x02\x10\n\r\n\x05\x05\x01\x02\x07\x01\
    \x12\x04\x8d\x01\x02\x0b\n\r\n\x05\x05\x01\x02\x07\x02\x12\x04\x8d\x01\
    \x0e\x0f\n\x0c\n\x04\x05\x01\x02\x08\x12\x04\x8e\x01\x02\x0f\n\r\n\x05\
    \x05\x01\x02\x08\x01\x12\x04\x8e\x01\x02\n\n\r\n\x05\x05\x01\x02\x08\x02\
    \x12\x04\x8e\x01\r\x0e\n\x0c\n\x04\x05\x01\x02\t\x12\x04\x8f\x01\x02\x10\
    \n\r\n\x05\x05\x01\x02\t\x01\x12\x04\x8f\x01\x02\x0b\n\r\n\x05\x05\x01\
    \x02\t\x02\x12\x04\x8f\x01\x0e\x0f\n\x0c\n\x02\x04\x11\x12\x06\x92\x01\0\
    \x94\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x92\x01\x08\x12\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\x93\x01\x02\x1a\n\r\n\x05\x04\x11\x02\0\x06\x12\
    \x04\x93\x01\x02\x0b\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x93\x01\x0c\x15\
    \n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x93\x01\x18\x19\n\x0c\n\x02\x04\x12\
    \x12\x06\x96\x01\0\x98\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x96\x01\
    \x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x97\x01\x02\x12\n\r\n\x05\x04\
    \x12\x02\0\x05\x12\x04\x97\x01\x02\x07\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\x97\x01\x08\r\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x97\x01\x10\x11\n\
    \x0c\n\x02\x04\x13\x12\x06\x9a\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\x9a\x01\x08\x13\n\x0e\n\x04\x04\x13\x08\0\x12\x06\x9b\x01\x02\
    \xa0\x01\x03\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\x9b\x01\x08\x0f\n\x0c\n\
    \x04\x04\x13\x02\0\x12\x04\x9c\x01\x04\x20\n\r\n\x05\x04\x13\x02\0\x06\
    \x12\x04\x9c\x01\x04\x0e\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x9c\x01\x10\
    \x1a\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x9c\x01\x1e\x1f\n\x0c\n\x04\x04\
    \x13\x02\x01\x12\x04\x9d\x01\x04\x20\n\r\n\x05\x04\x13\x02\x01\x06\x12\
    \x04\x9d\x01\x04\x0c\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x9d\x01\x10\
    \x18\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x9d\x01\x1e\x1f\n\x0c\n\x04\
    \x04\x13\x02\x02\x12\x04\x9e\x01\x04\x20\n\r\n\x05\x04\x13\x02\x02\x06\
    \x12\x04\x9e\x01\x04\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x9e\x01\
    \x10\x14\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x9e\x01\x1e\x1f\n\x0c\n\
    \x04\x04\x13\x02\x03\x12\x04\x9f\x01\x04!\n\r\n\x05\x04\x13\x02\x03\x06\
    \x12\x04\x9f\x01\x04\x0f\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x9f\x01\
    \x11\x1c\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x9f\x01\x1f\x20\n\x0c\n\
    \x02\x04\x14\x12\x06\xa3\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\xa3\x01\x08\x0c\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xa4\x01\x02\x10\n\
    \r\n\x05\x04\x14\x02\0\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x14\x02\
    \0\x01\x12\x04\xa4\x01\t\x0b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa4\x01\
    \x0e\x0f\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xa5\x01\x02\x13\n\r\n\x05\
    \x04\x14\x02\x01\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x14\x02\x01\
    \x01\x12\x04\xa5\x01\t\x0e\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa5\x01\
    \x11\x12\n\x0c\n\x02\x04\x15\x12\x06\xa8\x01\0\xad\x01\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\xa8\x01\x08\x13\n\x0c\n\x04\x04\x15\x02\0\x12\x04\
    \xa9\x01\x02\x1a\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xa9\x01\x02\n\n\r\n\
    \x05\x04\x15\x02\0\x06\x12\x04\xa9\x01\x0b\x0f\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xa9\x01\x10\x15\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xa9\x01\
    \x18\x19\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xaa\x01\x02\x16\n\r\n\x05\
    \x04\x15\x02\x01\x05\x12\x04\xaa\x01\x02\x08\n\r\n\x05\x04\x15\x02\x01\
    \x01\x12\x04\xaa\x01\t\x11\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xaa\x01\
    \x14\x15\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xab\x01\x02\x17\n\r\n\x05\
    \x04\x15\x02\x02\x05\x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\x15\x02\x02\
    \x01\x12\x04\xab\x01\t\x12\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xab\x01\
    \x15\x16\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xac\x01\x02\x1a\n\r\n\x05\
    \x04\x15\x02\x03\x05\x12\x04\xac\x01\x02\x08\n\r\n\x05\x04\x15\x02\x03\
    \x01\x12\x04\xac\x01\t\x15\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xac\x01\
    \x18\x19\n\x0c\n\x02\x04\x16\x12\x06\xaf\x01\0\xb2\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xaf\x01\x08\x16\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xb0\x01\x02\x13\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb0\x01\x02\x08\n\r\
    \n\x05\x04\x16\x02\0\x01\x12\x04\xb0\x01\t\x0e\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\xb0\x01\x11\x12\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xb1\x01\
    \x02\x12\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xb1\x01\x02\x08\n\r\n\x05\
    \x04\x16\x02\x01\x01\x12\x04\xb1\x01\t\r\n\r\n\x05\x04\x16\x02\x01\x03\
    \x12\x04\xb1\x01\x10\x11\n\x0c\n\x02\x04\x17\x12\x06\xb4\x01\0\xb6\x01\
    \x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xb4\x01\x08\x12\n\x0c\n\x04\x04\x17\
    \x02\0\x12\x04\xb5\x01\x02$\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xb5\x01\
    \x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xb5\x01\x0b\x19\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\xb5\x01\x1a\x1f\n\r\n\x05\x04\x17\x02\0\x03\x12\
    \x04\xb5\x01\"#b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
